\thesischapter{Formalising the European Rail Traffic Management System Using Hybrid Automata}{Formalising the European Rail Traffic Management System Using Hybrid Automata}
\chaptermark{Formalising ERTMS using Hybrid Automata}
\label{chap:hybrid}
The ERTMS system will be central to many train control systems in the future and ensuring that it is safe is of paramount importance. It poses a particular challenge due to the fact that the system is specified at a high level with each individual country having its own particular implementation. One aspect that is particularly problematic and loosely specified is the interface between the existing interlocking and the RBC as both of these systems have a role to play in ensuring safety. In the following chapter we shall look at formalising the ERTMS system whilst capturing the behaviour of this critical interface between the two systems. 
%
\section{Pentagon Case Study}
The following is a case study of a simple railway we shall use for the purposes of demonstrating our verification approach.  It contains five track segments connected to form a pentagon with two trains. This captures most of the behaviours found in a larger more complicated railway as the trains and control systems view any piece of track as a set of track segments joined together to form a route. We have modelled  a simple implementation of the ERTMS system controlling  a small railway in the shape of a pentagon (see Figure \ref{fig:pentagon2}) using three hybrid automata (see section \ref{sec:hybrid}). In this example the value $D$ represents the distance from the start point at time $t$. It contains two trains $A$ and $B$ and five track circuits $l_0, \ldots , l_4$. The track is uni-directional allowing trains to travel from $0 - 249$. 
\medskip
%
\begin{figure} [h!]
\begin{center}
\begin{tikzpicture}[node distance = 3cm]
\node (A) [draw,regular polygon, regular polygon sides=5, minimum size=6 cm,outer sep=0pt] {};
\foreach \n in {1,...,5} {
    \pgfmathtruncatemacro{\valuem}{\n - 1};
    \pgfmathtruncatemacro{\value}{(\n - 1) * 50};
    \node at (A.corner \n) [anchor=360/5*(\n-1)+270] {D = \value};
    \node at (A.side \n) [anchor = 360/5 *(\n-1) +270] {$l_{\valuem}$};
}

\node (B) [draw, rectangle, rotate = 36] at (-1.9,2.6) {Train A};
\node (C) [draw, rectangle, rotate =72] at (3,-1) {Train B};

\end{tikzpicture} 
\end{center}

 \caption{Pentagon Case Study}
 \label{fig:pentagon2}
\end{figure}

\begin{comment}



\def\r{3} 
\def\sone{ \sin 32}
\def\stwo{\sin 72}
\def\cone{\cos 32}
\def\ctwo{\cos 72}
\coordinate(top) at (0,\r);
\coordinate(topleft) at ({ \r * -cos (36)},{ \r * -sin (36)});
\coordinate(topright) at ({ \r * cos (72)}, { \r * -sin (72)});
\coordinate(botleft) at ({ \r * - cos (36)},{ \r * sin (36)});
\coordinate(botright) at ({\r * sin (72)},{\r * cos (72)});

\tikzstyle{box1}=[circle, draw, text width = 2cm, font=\scriptsize]
\tikzstyle{box3}=[rectangle, draw, text width = 2cm, font=\scriptsize]
\tikzstyle{arrow}=[->, thick]
\tikzstyle{biarrow}=[<->,very thick,shorten >=7pt,shorten <=7pt]


\node (A) [font = \scriptsize]  at (topleft)                  {D =150 };

\node (B) [font = \scriptsize]    at (botleft)          {D = 0};

\node (C)[font = \scriptsize] at (top)  { D = 100
						};

\node (D)[font = \scriptsize] at (botright)  { D = 50
						};

\node (E) [font = \scriptsize] at (topright) {D = 200};

\draw [arrow] (D) -- node[right] {$t_1$} (E);
\draw [arrow] (A) -- node[below = 10pt] {$t_4$} (B);
\draw [arrow] (B) --  node[above = 10pt] {$t_2$} (C);
\draw [arrow] (C) -- node [left] {$t_3$} (D);
\end{comment}
%
\section{Modelling Assumptions}
Since this is a first attempt at modelling a complex system we make several assumptions of the model in order to make it manageable so that we can capture its behaviour in a formal specification language and verify it using a model checker.
%
\begin{enumerate}

\item The train track is uni-directional.

\item The train will make maximal progress i.e. the train will accelerate whenever allowed by the movement authority and brake when the movement authority requires it.

\item The trains can only accelerate one unit of speed per unit time interval.

\item All trains are fitted with the ERTMS system.

\item The positioning systems on the train are assumed to function at all times, constantly providing the radio block processor with correct information regarding the location of the train.

\item We only allow movement authority extensions of one track segment in distance (50 in the pentagon case study).

\item We do not allow movement authorities to be revoked.

\item We assume that the track will be under the control of one radio block processor.

\item If we work with an open section of track in which trains can enter and leave, we shall assume that the handover is performed correctly in an automatic fashion.

\item In an open track plan a train will be allowed to enter as the separation policy allows.
\end{enumerate}
%
The assumption regarding the acceleration causes the speed to be a linear function of time and greatly simplifies the laws of motion needed to compute the braking curves.   We do not allow movement authorities to be revoked for two reasons; the first is that it makes the verification of safety properties far more difficult and the second is that the model we have is quite simple and the pentagon case study does not contain any situations which would cause a movement authority to be revoked.
%
\section{Modelling ERTMS Using Hybrid Automata} \label{sec:hybrid}
One formalism which we can use to reason about systems such as ERTMS is hybrid automata \cite{TH96}. We shall give a theoretical overview of hybrid automata before formalising ERTMS as three hybrid automata composed in parallel. A hybrid automaton has discrete states called control modes and transitions between these modes called control switches. These control switches are triggered by either some condition on variables or by some event occurring. These events can either occur in some other automaton or they can be fired by an automaton due to some condition being met. The continuous transitions of the automaton are described by dotted variables\footnote{The dotted variables represent the rate of change of a given variable over time i.e. $\dot{y}$ denotes the derivative of $y$  $\dot{y} = \frac{dy}{dt}$. This notation was introduced by Newton \cite{CF28}.} and occur continually over time.
\medskip
\begin{mydef}[Hybrid Automaton: Syntax]\label{def:hybridautomatonsyntax}
The syntax of a hybrid automaton $H$ comprises of the following:
\begin{description}
\item[Variables] A finite set $X = \{x_1, \ldots x_n \}$ of variables which range over the real numbers. The cardinality of $|X|$ is called the \emph{dimension} of $H$. The variable set has a corresponding dotted variable set $\dot{X} = \{\dot{x}_1, \ldots \dot{x}_n \}$ which represents the continuous changes of variables and a primed variable set $X' = \{x'_1, \ldots , x'_n \}$ that represents  values at the conclusion of a discrete change.

\item[Control graph] A finite directed multigraph $(V,E)$ consisting of a set of vertices $V$ which we shall refer to as \emph{control modes} and a set of edges $E$ which we shall refer to as \emph{control switches}.

\item[Initial, invariant and flow conditions] Three functions $\mathrm{init}$, \emph{inv} and \emph{flow} that label each control mode $v \in V$ with three predicates such that for all $v \in V$, $\freevar{\mathrm{init}(v)} \subseteq X$, $\freevar{\mathrm{inv}(v)} \subseteq X$ and $\freevar{\mathrm{flow}(v)} \subseteq X \cup \dot{X}$, where $\freevar{P}$ is the set of free variables in the predicate $P$.


\item[Jump Conditions] A function \emph{jump} that labels each edge $e \in E$ with a predicate such that $\freevar{\mathrm{jump}(e)} \subseteq X \cup X' $.

\item[Events] A finite set $\Sigma$ of \emph{events}, one of which is assigned to  each control switch by a labelling function $\mathrm{event}: E \to \Sigma$.

\end{description}

\end{mydef}
\medskip
The $\mathrm{init}$ function is used to define initial states of the system. Later (see section \ref{sec:hyseman}) these initial states become initial states of a labelled transition system when we define the semantics of hybrid automata. The $\mathrm{inv}$ function is used to define regions in which the state of the hybrid automaton exists. If the invariant ceases to hold in one control mode then time can no longer progress in that mode and a jump must occur for time to progress. The $\mathrm{flow}$ function describes the rate of change of variables in a particular state. The $\mathrm{jump}$ predicate describes the causes and effects of a discrete transition along a control switch using the un-primed and primed variables respectively.  Events are used to capture the passing of messages between different hybrid automata composed in parallel.
\begin{comment}
For example, when we define our train control system it is desired that the S of the train is $0$, initially and that remains invariant throughout execution of the automaton $init(Stopped) := invar(Stopped) := S = 0$ , which is captured by the initial predicate $init(Stopped) := S = 0$.  It is also desirable in the states Accelerating and Full Speed that the braking distance is less than or equal to the distance between the train and the end of movement authority $inv(Acc) := inv(Full Speed) := BD(S) \leq DMA(D, EoA)$. The invariant acts as a boundary condition which specifies the limits of the automatons behaviour. In the case of the Full Speed and Accelerating states it ensures that the train can always brake in time and it forces the automaton to perform a transition to the braking state when the boundary of the invariant is reached . If some some reason the system flows into one of these boundaries and no discrete change can occur then time is prevented from continuing.  \end{comment}

Automata which contain states from which time cannot progress are called \emph{Zeno}. In order to form a transition system from the automaton, it must be \emph{non-Zeno} i.e. time can always progress in every state of the system. 
\medskip
\begin{comment}
 In the following specification events are used to pass messages between different automata placed in parallel. An example event is that of $event(Stopped \to Accelerating) :=MA.x.y \ \textbf{if} \ x = TrainID \ \textbf{then} \ EoA' := y$ which is triggered by the RBC and causes the train to update the value of its movement authority. Flow conditions describe the rate of change of a given variable over time. In our formalisation of a train one such flow condition is $flow(Accelerating) := \dot{S} = 1$ which causes the train to accelerate at a S of one unit per unit of time.
\end{comment}

\begin{myremark}[Multievents and messages]
We use multiple events, edges and $\mathrm{flow}$ conditions to encode passing of messages that include some data between automata.  We denote a multievent using an sequence of labels $e_n$ and data $x_n$ composed using a ``.".  For each possible value of $x$, there is a corresponding edge, event and flow triple that captures the effect of receiving a message containing $x$.
\end{myremark}

\begin{myremark}[Automaton Diagrams]
We draw arrows in our automaton diagrams to represent control mode jumps and flows with events. We do not draw arrows to represent a flow without an event as such time transitions are possible in all modes.
\end{myremark}
\subsubsection*{Laws of Motion}\label{sec:lawsofmotion}
In the following we shall describe how to use the laws of motion to capture the motion of the train.
The behaviour of the train is based on two of Newton's laws of motion:
\begin{enumerate}
\item $S_{Final} = S_{Initial} +AT$
\item$S_{Final}^2 = S_{Initial}^2 +2AD$
\end{enumerate}
 Where $D$ = distance, $S_{Initial}$ = initial speed, $S_{Final}$ = final speed, $A$ = acceleration and $T$ = time. In our modelling approach a train has a position which is its distance from an initial starting point. In order to model the behaviour of trains we make use of two functions, one to compute the braking distance at the current speed and the other to compute the distance from the train to the end of the movement authority. When the values computed by these two functions become equal the train should begin to brake in order to stop at the end of the movement authority. The simplest way to model deceleration would be to assume that the train's speed decreases at a constant deceleration of  $-1$ unit of distance per unit of time. The second equation of motion  is used to calculate the braking distance with $S_{Initial} = 0$ and $A = -1$. It can be rewritten to allow for the calculation of the braking distance.
\medskip

As a consequence of the above, the braking distance for a train in terms of its speed $S$ and (constant) acceleration $A$ is: 

$$\BD{S,A} = \frac{S^2}{-2A} $$
Since the acceleration is  $-1$ in our model it is possible to remove $A$ from the above equation.

\begin{mydef}[Braking Distance]
We define the braking distance as follows:

$$\BD{S} = \frac{S^2}{2}$$

\end{mydef}
\medskip
Since we are working with a loop in the track the distance to the movement authority is calculated modulo the length of the track. 
\medskip

\begin{mydef}[Distance to Movement Authority]

The distance to the movement authority $\mathrm{DMA}$ is calculated from the distance (D) and end of authority (EoA) as follows:
\begin{align*}
\DMA{D}{EoA} & = EoA \Monus D \quad \mathbf{if} \ D \leq EoA \\
                         & = 250 \Monus D + EoA \quad \mathbf{otherwise}
\end{align*}

\end{mydef}

Together, both of these functions form are used to compute whether or not the train is far enough from the end of its movement authority and slow enough to be able to stop inside the movement authority. In the hybrid automaton they form a crucial invariant which determines whether the train should accelerate or brake.


\subsection*{Train Automata}
The train hybrid automaton (See Figure \ref{fig:TrainAuto}.) has four control modes namely $Braking \, (Auth)$, $Full \, Speed$, $Accelerating$ and $Stop$ and has three variables namely $D$ (Distance),  $S$ (Speed) and $EoA$ (End of movement authority). We have transitions of the form $(A \to B)_y$, where $A$ and $B$ are control modes and $y$ is a label, which enable us to refer to a particular transition in a jump condition and event. The meaning  of $A \to B$ is that the automaton has transitioned from control mode $A$ to control mode $B$. We define a control switch with the event $l_x.l_{x+1}$ that is triggered by the condition $D \, mod \, 50 = 0$ in the modes $Full \, Speed$, $Accelerating$ and $Brake$ which captures the transition of the train from one track segment to another. It is possible for a new movement authority $EoA'$ to be received with $EoA < EoA'$  in the $Braking$ and $Stopped$ states.  This is triggered by the event $MA.x.y$ occurring then if the variable $x$ matches the train identifier $TrainID$ then $y$ becomes the new movement authority. Multiple events capture the passing of a message such $MA.x.y$ with one for each possible value of $x$ and $y$. The movement event $MA.Req.x$ is used by a train automaton requesting a movement authority for train $x$ from the RBC automaton.
\medskip
\begin{mydef}[Train Automaton]
We define a hybrid automaton $H_{T}$ as follows:
\begin{description}
\item[Variables] The state of the train automaton consists of $D, EoA \in \{0, \ldots , 249 \}$, $ S, TrainID \in {\mathbb{N}}$. 

\item[Control Graph] The control graph of the interlocking automaton consists of four control modes $\{Stop \, (EoA), \, Braking, \, Accelerating, \, Full \,  Speed \}$ and control switches $(Full \, Speed \to  Full \, Speed)\_1$, $(Full \, Speed \to Full Speed)\_2$, $(Accelerating \to Accelerating)\_1$, $(Accelerating \to Accelerating)\_2$, $(Braking \to Braking)\_1$, $(Braking \to Braking)\_2$,  $Full \, Speed \to Braking$, $Braking \to Accelerating$, $Accelerating \to Braking$  $Braking \to Stop \, (EoA)$, 

\item[Initial conditions] \hspace*{0mm}
\begin{itemize} 
	\item $init(Stop \, (EoA)) :=   \BD{S} \leq \DMA{D}{EoA}  $
	\item $init(Stop \, (EoA)) :=   S = 0  $
\end{itemize}

\item[Invariants] \hspace*{0mm}
	\begin{itemize}
	\item $inv(Full \, Speed) :=   S = MaxSpeed \wedge \BD{S} \leq \DMA{D}{EoA}$ 

	\item $inv(Braking)  :=  \BD{S} = \DMA{D}{EoA}$
         \item $inv(Accelerating) := \BD{S} \leq \DMA{D}{EoA}$

	\item $inv(Stop (EoA)) := S = 0 \wedge D = EoA$ 
	\end{itemize}
             
\item[Flow conditions] \hspace*{0mm}
	\begin{itemize}
	\item $flow(Accelerating):= \dot{S} = 1$ 
	
	\item $flow(Braking) := \dot{S} = -1$

	\item $flow(Stopped) := flow(Full Speed) := \dot{S} = 0$
 
	\end{itemize}

\item[Jump Conditions] \hspace*{0mm}
\begin{itemize}
	\item  $jump(Braking \to Accelerating) := jump(Stop (EoA) \to Accelerating) :=  EoA' = y$ 
	\item $jump(Full \, Speed \to Braking) := jump(Accelerating \to Braking) := \DMA{D}{EoA} = \BD{S}$
	\item $jump(Accelerating \to Full \, Speed) := S = MaxSpeed$	
	\item $jump(Braking \to Stop \, (EoA)) := S = 0$
	\item $jump((Braking \to Braking)\_1) := jump((Accelerating \to Accelerating)\_1) := jump((Full \, Speed \to Full \, Speed)\_1) := D \, mod \, 50 = 0$
\end{itemize}

\item[Events] \hspace*{0mm}
\begin{itemize}
	\item $event (Stop \, (EoA) \to Accelerating) := MA.TrainID.y$
	\item $event (Braking \to Accelerating) := MA.TrainID.y$
	\item $event((Full \, Speed \to Full \, Speed)\_1) := event((Braking \to Braking)\_1)$ \\
                  $:= event((Accelerating \to Accelerating)\_1)  := l_{D \, div \, 50}.l_{(D \, div \, 50) +1}$
\item $event((Full \, Speed \to Full \, Speed)\_2) := event((Braking \to Braking)\_2)$  \\
        $:= event((Accelerating \to Accelerating)\_2) := Train.TrainID.Pos.D$
	\item $event(Accelerating \to Braking) = MA.Req.TrainID$
	\item $event(Full \, Speed \to Braking) = MA.Req.TrainID$
\end{itemize}

\end{description}
\end{mydef}
\medskip
\begin{figure} [H]

\begin{center}
\begin{tikzpicture}[node distance = 2cm]

\tikzstyle{box1}=[circle, draw, text width = 2cm, font=\scriptsize, text centered]
\tikzstyle{box3}=[rectangle, draw, text width = 2cm, font=\scriptsize]
\tikzstyle{arrow}=[->,shorten >=7pt,shorten <= 7pt]
\tikzstyle{biarrow}=[<->,very thick,shorten >=7pt,shorten <=7pt]


\node (A) [box1]  at (0,0)                  {{\large \textbf{Stop (EoA)}} \\
							$S = 0$ \\
                                                        $\dot{S} = 0$
							$D = EoA$ 

                                            };

\node (B) [box1]    at (7.5,0)          {{\large \!\!\!\!\textbf{Accelerating}} \\
       $\dot{S} = 1$
       $\BD{S} \leq \DMA{D}{EoA}$
       $S \leq MaxSpeed$

};

\node (C)[box1] at (0, 7.5)  {{\large \textbf{Braking}}\\
					                   $\dot{S} = -1$ 
						           $\BD{S} = \DMA{D}{EoA}$
                                               
						};

\node (D)[box1] at (7.5, 7.5)  { {\large \textbf{Full Speed }} \\
					                   $S = MaxSpeed$
                                                            $\dot{S} = 0$
							    $\BD{S} \leq \DMA{D}{EoA}$
                                               
						};


\draw [arrow] (B) -- node[right] {$S = MaxSpeed$} (D);
\draw [arrow] (A) -- node[below = 10pt, text width = 4cm] {\begin{center}MA.x.y\\ \textbf{if} x = TrainID\\ \textbf{then} MA := y\end{center} } (B);
\draw [arrow] (D) --  node[above = 10pt,text width=4cm] {\begin{center}DMA(D, EoA) =\\ BD(S)\\MA.Req.TrainID \end{center}} (C);
\draw [arrow] (C) -- node [left] {$S = 0$} (A);
\draw [arrow] (B)  .. controls +(-1.5cm,  1.5 cm) and +(1.5cm,  -0.5 cm ) .. node [right,text width=4cm] { \begin{center}DMA(D,EoA) =\\
    BD(S)\\MA.Req.TrainID \end{center}} (C);
\draw [arrow] (C) .. controls +(1.5cm,  -1.5cm) and +(-2cm, 1.0 cm ) ..   node [left,text width = 4cm] {\begin{center}MA.x.y\\ \textbf{if} x = TrainID \\ \textbf{then} MA := y\end{center} } (B);
\draw [arrow] (C) .. controls +(-2cm,  2cm) and +(-2cm, 0.5 cm ) ..   node [above = 10pt, text width = 4cm] {\begin{center}\textbf{train movement events} \end{center}} (C);
\draw [arrow] (D) .. controls +(2cm,  2cm) and +(2cm, 0.5 cm ) ..   node [above = 10pt, text width = 4cm] {\begin{center} \textbf{train movement events} \end{center}} (D);
\draw [arrow] (B) .. controls +(2cm,  -2cm) and +(2cm, -0.5 cm ) ..   node [below = 6pt, text width = 4cm] {\begin{center}\textbf{train movement events} \end{center}} (B);

\end{tikzpicture} 
\end{center}
\caption{Train Automaton}
\label{fig:TrainAuto}
\end{figure}
\medskip
\begin{myremark}[Train Movement Events]
We use the following abbreviation to capture the two separate events and flow conditions for train movement in the automaton diagram:
\begin{align*}
\mathbf{train \, movement \, events} \, := \ &\mathbf{if} \ D \, mod \, 50 = 0 \\
						&\mathbf{then} \ l_{D \, div \, 50}.l_{D \, div \, 50 +1}, \\
					        &Train.TrainID.Pos.D 
\end{align*}
\end{myremark}


\subsection*{Interlocking Automata}
In the following we shall define a hybrid automaton that captures the behaviour of the solid state interlocking (See Figure \ref{fig:ILAuto}.).  The automaton has two control modes, namely $Idle$ and $Response$, which capture that the interlocking is either idle or processing a response to a request.  The automaton has five Boolean variables $\{ l_0, \ldots ,l_4 \}$ representing whether a track segment is occupied or not and a variable $ReqID$ which stores the last requested track segment. The intended meaning of $l_i = true$ is that the track is occupied.  When a request for a track segment is made that track segment is stored, then if the track freedom condition is met then a request is granted, otherwise it is denied. The event $l_x.l_{x+1}$ captures the movement of a train from one track segment to the next in both the interlocking automaton and the train automaton.
\medskip
\begin{mydef}[Interlocking Hybrid Automaton]
We define a hybrid automaton $H_{IL}$ as follows:
\begin{description}
\item[Variables] The state of the interlocking automaton consists of five Boolean variables  $l_0, \ldots , l_4  \in \{Occupied, Free\}$ and a variable $ReqID \in \{0 , \ldots , 4 \}$ storing the last requested track segment.

\item[Control Graph] The control graph of the interlocking automaton consists of two control modes $\{Response, Idle \}$ with five control switches connecting them: $Response \to Idle$, $(Response \to Idle)_2$, $Idle \to Response$, $Response \to Response$, $Idle \to Idle$.

\item[Initial conditions] \hspace*{0mm}
	\begin{itemize}
	\item $init(Idle) := l_0 = True, l_1 = False, l_2 = False, l_3 = True, l_4 = False$.

	\end{itemize}

\item[Jump Conditions] \hspace*{0mm}

	\begin{itemize}
	\item $jump(Idle \to Response) :=  ReqID' = z$

	
	\item $jump(Response \to Idle) :=  l_{ReqID} = Free $ 
    

         \item $jump((Response \to Idle)_2)) :=  \neg l_{ReqID} = Free$


	\item $jump(Idle \to Idle) :=  l_x' = Free, l_{x+1}' = Occupied$

	\item $jump(Response \to Response) := l_x' = Free, l_{x+1}' = Occupied$


	\end{itemize}

\item[Events] \hspace*{0mm}
\begin{itemize}
	\item $event(Idle \to Response) := Req.z$
	\item $event(Response \to Idle) := Grant.z$
	\item $event((Response \to Idle)_2)) := Deny.z$
	\item $event(Idle \to Idle) := l_x.l_{x+1}$
	\item $event(Response \to Response) := l_x.l_{x+1}$	
\end{itemize}

\end{description}
\end{mydef} 
\medskip
\FloatBarrier
\begin{figure} [H]

\begin{center}
\begin{tikzpicture}[scale = 0.60]

\tikzstyle{box1}=[circle, draw, text width =3cm , text centered]
\tikzstyle{box3}=[rectangle, draw, text width = 2cm, font=\scriptsize]
\tikzstyle{arrow}=[->,shorten >=7pt,shorten <= 7pt]
\tikzstyle{biarrow}=[<->,very thick,shorten >=7pt,shorten <=7pt]



\node (B) [box1]    at (7.5,0)          {\textbf{Idle}
};

\node (C)[box1] at (0, 7.5)  { \textbf{Response} };


\draw [arrow] (B)  .. controls +(-1.5 cm,  2.75 cm) and +(4.5cm,  -2.5cm ) .. node [right, text width=4cm] {Req.z} (C);
\draw [arrow] (C) .. controls +(1cm,  -3cm) and +(-2.75cm, 1 cm ) ..   node [left = 3 cm, below, text width = 6cm] {$Grant.z \  \mathbf{if} \ t_{ReqID} = \ free $\\$ \mathbf{else} \ Deny.z \ Otherwise$} (B);


\draw [arrow] (B) .. controls +(3cm,  3cm) and +(3cm, 1.5 cm ) ..   node [above = 10pt, right = 10pt, text width = 4cm] {$l_{x}.l_{x+1}$ \\ $l_x' := Free$ \\ $l_{x+1}' := Occupied$ } (B);


\draw [arrow] (C) .. controls +(3cm,  3cm) and +(3cm, 1.5 cm ) ..   node [above = 10pt, right = 10pt, text width = 4cm] {$l_{x}.l_{x+1}$ \\ $l_x' := Free$ \\ $l_{x+1}' := Occupied$} (C);

\end{tikzpicture} 
\end{center}

\caption{Interlocking Automaton}

\label{fig:ILAuto}
\end{figure}



\begin{comment}



\begin{figure} [H]

\begin{center}
\begin{tikzpicture}[node distance = 3cm]

\tikzstyle{box1}=[circle, draw, text width = 2cm, font=\scriptsize]
\tikzstyle{box3}=[rectangle, draw, text width = 2cm, font=\scriptsize]
\tikzstyle{arrow}=[->,shorten >=7pt,shorten <=7pt]
\tikzstyle{biarrow}=[<->,very thick,shorten >=7pt,shorten <=7pt]


\node (A) [box1]  at (0,0)                  {\begin{center} \textbf{)} \\
							$\dot{D}(t) = 0$  \end{center}

                                            };

\node (B) [box1]    at (5,0)          {\begin{center} \textbf{Accelerating} \\
       $\dot{D}(t) = pSs$  \end{center}

};

\node (C)[box1] at (0, 5)  { \begin{center} \textbf{Braking (Auth)}\\
					                   $\dot{D}(t) = nS$ \end{center}
                                               
						};

\node (D)[box1] at (5, 5)  { \begin{center} \textbf{Full Speed }\\
					                   $\dot{D}(t) = max\, S$ \end{center}
                                               
						};


\draw [arrow] (B) -- node[right] {$\dot{D}(t) = max S$} (D);
\draw [arrow] (A) -- node[below = 10pt] {Rece new MA} (B);
\draw [arrow] (D) --  node[below = 10pt] {$t = \ldots$} (C);
\draw [arrow] (C) -- node [left] {$S = 0$} (A);


\end{tikzpicture} 
\end{center}


\caption{Train Automaton}
\label{fig:TrainAuton}
\end{figure}
\end{comment}

\subsection{Radio Block Processor Automata}
Similarly to the train automaton the RBC automaton also has four control modes namely $Granted$, $Idle$, $Wait$ and $Ready \, to \, Request$. Initially the system is in an idle state where the system waits until it receives a movement authority request MA.Req.x. When the train receives such a movement authority request the LastTrain variable is assigned to be x and the system moves to the $Ready \, to \, Request$ state.  From this state the train sends a request for the next track segment of the $LastTrain$. In the following definition we have defined the initial state of the RBC for the pentagon case study with the initial positions of the trains A and B being $0$ and $150$ and their movement authorities being $49$ and $199$ respectively. The state of the RBC automaton consists of two sets of variables $EoA_1, Pos_1$ and $EoA_2, Pos_2$ that each correspond to one of the trains in the example.
\medskip

\begin{mydef}[Radio Block Controller Hybrid Automaton]

We define a hybrid automaton $H_{RBC}$ as follows:
\begin{description}
\item[Variables] The state of the radio block controller automaton consists of $EoA_1, Pos_1, EoA_2, Pos_2 \in  \{0, \ldots , 249\}$, $LastTrain \in \mathbb{N}$.

\item[Control Graph] The control graph of the radio block controller automaton consists of four control modes $\{Idle, \, Ready \, to \, Request, \, Wait, \, Granted \}$ and control switches $Ready \, to \, Request \to Ready \, to \, Request$, $Granted \to Granted$ $Wait \to Wait$, $Idle \to Idle$, $Idle \to Ready \, to \, Request$, $Ready \, to \, Request \to Wait$, $Wait \to Ready \, to \, Request$, $Wait \to Granted$ and $Granted \to Idle$.

\item[Initial, invariant and flow conditions] \hspace*{0mm}
	\begin{itemize}
	\item $init(Idle) :=   EoA_1 = 49, Pos_1 = 0, EoA_2 = 199, Pos_2 = 150, LastTrain = 0 $
	\end{itemize}

\item[Jump Conditions] \hspace*{0mm}

	\begin{itemize}
	\item $jump(Ready \, to \, Request \to Ready \, to \, Request) :=  Pos.x = y$
	\item $jump(Wait \to Wait) :=  Pos.x = y$
	\item $jump(Granted \to Granted) :=  Pos.x = y$
	\item $jump(Idle \to Idle) := Pos.x = y$
	\item $jump(Idle \to Ready \, to \, Request) := LastTrain = x$
	\item $jump(Granted \to Idle) := EoA_{LastTrain} = EndOf(NextTrack(Pos_{LastTrain}))$
	\end{itemize}

\item[Events] \hspace*{0mm}
\begin{itemize}
\item $event(Ready \, to \, Request \to Ready \, to \, Request) := Train.x.Pos.y$
	\item $event(Wait \to Wait) := Train.x.Pos.y$
	\item $event(Granted \to Granted) := Train.x.Pos.y $
         \item $event(Idle \to Idle) := Train.x.Pos.y$
	\item $event(Idle \to Ready \, to \, Request) := MA.Req.x $
	\item $event(Ready \, to \, Request \to Wait) := Req.NextTrack(Pos.LastTrain)$
	\item $event(Wait \to Ready \, to \, Request) := Deny.x$
	\item $event(Wait \to Granted) := Grant.x$
	\item $event(Granted \to Idle) := MA.LastTrain.EndOf(NextTrack(Pos.LastTrain))$
\end{itemize}

\end{description}

\end{mydef}


Safety conditions for the combined system can be separated into discrete and continuous parts.  If we want to specify a safety condition which states that it is not possible for two trains to collide in our current system this could have the following components. The continuous part would state that any movement authority issued by the radio block processor would respect the interlocking's separation policy. The discrete part would basically state that two trains do not occupy the same track segment.

\FloatBarrier

\begin{figure} [H]

\begin{center}
\begin{tikzpicture}[node distance = 1cm]

\tikzstyle{box1}=[circle, draw, text width = 2cm, text centered ]
\tikzstyle{box3}=[rectangle, draw, text width = 2cm, font=\scriptsize]
\tikzstyle{arrow}=[->,shorten >=7pt,shorten <= 7pt]
\tikzstyle{biarrow}=[<->,very thick,shorten >=7pt,shorten <=7pt]


\node (A) [box1]  at (0,0)                  {\textbf{Idle} };

\node (B) [box1]    at (7.5,0)          { \textbf{Ready to Request} };

\node (C)[box1] at (0, 7.5)  { \textbf{Granted}};

\node (D)[box1] at (7.5, 7.5)  { \textbf{Wait} };


\draw [arrow] (B)  .. controls +(0.5cm,  1.5 cm) and +(0.5cm,  -1.5 cm ) .. node[right, text width = 3cm] {\begin{center}$Req.NextTrack($ \\ $Pos.LastTrain)$ \end{center}} (D);
\draw [arrow] (D) .. controls +(-0.5cm,  -1.5cm) and +(-0.5cm, 1.5 cm ) ..   node [left] {$Deny.x$} (B);
\draw [arrow] (A) -- node[below = 10pt, text width = 4cm] {\begin{center}$MA.Req.x$ \\ $LastTrain := x$\end{center}} (B);
\draw [arrow] (D) --  node[above = 10pt,text width=4cm] {\begin{center}$Grant.x$\end{center}} (C);
\draw [arrow] (C) -- node [left, text width = 4cm] {$MA.x.EndOf($ \\ $NextTrack($ \\ $Pos.LastTrain))$} (A);

\draw [arrow] (C) .. controls +(-2cm,  2cm) and +(-2cm, 0.5 cm ) ..   node [above = 5pt, text width = 4cm] {\begin{center}$Train.x.Pos.y$\\ Pos.x := y\end{center}} (C);
\draw [arrow] (D) .. controls +(2cm,  2cm) and +(2cm, 0.5 cm ) ..   node [above = 5pt, text width = 4cm] {\begin{center}$Train.x.Pos.y$\\ Pos.x := y\end{center}} (D);
\draw [arrow] (B) .. controls +(2cm,  -2cm) and +(2cm, -0.5 cm ) ..   node [below = 6pt, text width = 4cm] {\begin{center}$Train.x.Pos.y$\\ Pos.x := y\end{center}} (B);
\draw [arrow] (A) .. controls +(-2cm,  -2cm) and +(-2cm, -0.5 cm ) ..   node [below = 6pt, text width = 4cm] {\begin{center}$Train.x.Pos.y$\\ Pos.x := y\end{center}} (A);


\end{tikzpicture} 
\end{center}
\caption{Radio Block Processor Automaton}
\label{fig:RBCAuton}
\end{figure}

\subsection*{Inter-automaton Communication}
The message sequence diagram Figure \ref{fig:SeqChart2} shows the communication between the RBC, interlocking and Train 1 from the pentagon case study. The aim of this diagram is to provide the reader with a feel for how events are used to capture messaging and the passing of information between the automata. Train 1 is initially 1 unit of distance from the start of the track.  Train 1 initially sends position updates to the RBC until it reaches its braking point, at which time it will request a movement authority the RBC. The first position update is the event Train.1.Pos.1 where the train ID and the position have both been instantiated with 1.  The RBC will then request the next track segment for the train, which in this case is immediately granted. The RBC then sends the train its new movement authority using an event with train ID 1 and the end of authority instantiated with 99. Some of the position updates have been omitted from the diagram.
\begin{figure} [h!]

\begin{center}
\begin{tikzpicture}[node distance = 3cm, scale = 1.5]
\tikzstyle{arrow}=[->,shorten >=7pt,shorten <=7pt]

\draw (0,10) --  (0,6.5);

\draw (2, 10) -- (2, 6.5);

\draw (4, 10) -- (4, 6.5);

\node[] at (0, 10.5) {RBC};
\node[] at (2, 10.5) {Interlocking};
\node[] at (4, 10.5) {Train 1};

\draw [->](4,9.5) -- (0,9.5);
\draw  (2, 9.5) -- node[above, font = \small]{Train.1.Pos.1}(4,9.5); 


\draw [->](4,9) -- (0,9);
\draw  (2, 9) -- node[above, font = \small]{Train.1.Pos.36}(4,9); 


\draw [->](4,8.5) -- (0,8.5);
\draw  (2, 8.5) -- node[above, font = \small]{MA.Req.1}(4,8.5); 

\draw [->] (0, 8) -- node[above, font = \small]{Req.1}(2,8); 


\draw [->] (2, 7.5) -- node[above, font = \small]{Grant.1}(0,7.5); 

\draw [->](0,7) -- (4,7);
\draw  (0, 7) -- node[above, font = \small]{MA.1.99}(2,7); 

%\draw[->](0, 9.5) -- node[above, font = \small ]{Route Req} (2, 9.5);
%\draw[<-](0, 9) -- node[above, font = \small]{Route Ack}(2,9); 


%\draw[->](0, 8.5) -- node[above, font = \small]{MA D $\to$ C} (4, 8.5);
%\draw[<-](0, 8) -- node[above, font = \small]{MA Ack} (4, 8);  
%\draw[<-](0, 7.5) -- node[above, font = \small]{Position Data} (4, 7.5);  


%\draw [arrow] (0,9) -- node[above = 7pt] {Comm Sess Init} (7 ,7 );
%
%\draw [arrow] (7,6.5) -- node[above = 7pt] {System Version} (0 , 4.5);
%\draw [arrow] (0,4) -- node[above = 8pt, text width = 3.3cm] {Report and Tele No (Compatable)}  (7 ,2 );
%\node[text width = 3.5cm] at (3.5, 2) {Version Incompatable (Incompatable)};
%
%\node[rectangle,draw] at (-2 , 4.25) {Check Compatibility};
%\draw [arrow] (-0.5,4) -- node [left, text width = 2 cm] {Connection Established (Compatable)}  (-0.5, 0);
% \draw [arrow] (7.5,2) -- node [right, text width = 2 cm] {Connection Established (Compatable)}  (7.5, 0);


\end{tikzpicture}
\end{center}

\caption{Message Sequence Chart Demonstrating Inter-automaton Communication}
\label{fig:SeqChart2}
\end{figure}







\section{Semantics of Hybrid Automata} \label{sec:hyseman}

The semantics hybrid automata are captured using labelled transition systems. These transition systems allow us to model the behaviour of a system with a possibly infinite number of discrete labelled states. 
\medskip
\begin{mydef}[Labelled Transition System]
We define a \emph{labelled transition system} $LTS = (S,S_0,L,T)$ as follows:
\begin{itemize}

\item $S$ is a possibly infinite set of states

\item $S_0$ is a set of initial states $S_0 \subseteq S$

\item $L$ is a set of \emph{labels}

\item $T$ is ternary  relation $S \xrightarrow{a} S$ of type $S \times L \times S$.

\end{itemize}
\end{mydef}
\medskip
When defining the semantics of a hybrid automaton we need to be able to speak about parts of the state space.  We define a \emph{region} as being a subset of the state space $R \subseteq S$.  This enables us to define, for example, a continuous region for an initial state of a system rather than a discrete state. The semantics of an hybrid automaton \cite{TH96} is defined in terms of a timed transition system which use transitions to capture the flows and jumps and an infinite number of states to capture the continuous nature of the hybrid automaton's real-numbered variables.

\medskip
\begin{mydef}[Transition Semantics of Hybrid Automata]
We define the semantics of a hybrid automaton $H$ (See definition \ref{def:hybridautomatonsyntax}) in terms of a \emph{timed transition system} $LTS^t_H = (S,S_0,L,T)$ as follows:


\begin{itemize}
 
\item The state space $S$ of the timed transition system is defined as, $S, S_0 \subseteq V \times R^n$, where $R$ is the set of real numbers and $n$ the number of variables in $X$ . A state is in the state space $(v,x) \in S_0$ iff the closed predicate $inv(v)[X := x]$ holds. In addition to the previous condition a state is in the initial state space $(v,x) \in S_0$ iff the closed predicate $init(v)[X := x]$ holds. We call a subset of the state space $S$ a \emph{H-region}.


\item $L = \Sigma \cup R_{\geq 0}$

\item For all events $\sigma \in \Sigma$ such that there exists a control switch $e \in E$, we define $(v,x) \xrightarrow{\sigma} (v',x')$ iff the following conditions are satisfied:
\begin{enumerate}
\item the source and target of $e$ are $v$ and $v'$ respectively
\item the closed predicate $jump(e)[X, X' := x,x']$ holds
\item $event(e) = \sigma$
\end{enumerate}

\item We define a transition $(v,x) \xrightarrow{\delta} (v,x')$ for all non-negative reals $\delta \in R_{\geq 0}$ iff there exists a differentiable function $f: [0, \delta] \to R^n$ such that the following holds:
\begin{enumerate}
\item The functions first derivative is $\dot{f} :(0,\delta) \to R^n$
\item $f(0) = x$
\item $\forall \epsilon \in (0,\delta)$ both of the predicates $inv(v)[X := f(\epsilon)]$ and $flow(v)[X,\dot{X} := f(\epsilon),\dot{f}(\epsilon)]$ hold
\end{enumerate}
We call the function f the \emph{witness} of the transition $(v,x) \to (v, x')$.

\end{itemize}


\end{mydef}
\medskip
\begin{mydef}[$q_0$-rooted and initialised trajectories]
Given a labelled transition system $LTS = (S,S_0,L,T)$ and a state $s \in S$. We define a $q_0$-\emph{rooted} \emph{trajectory} as a finite or infinite sequence of pairs $\langle a_i, q_i \rangle_{i \geq 1}$ of labels $a_1 \in L$ and states $q_i \in S$  such that $q_{i-1} \xrightarrow{a_i} q_{i} \in T$ for all $i \geq 1$. If $q_0 \in S_0$ then the sequence of pairs $\langle a_i, q_i \rangle_{I \geq 1}$ is an \emph{initialised trajectory}. 
\end{mydef}
\medskip
\begin{mydef}
We define a live transition system (LTS,A) to consist of a labelled transition system $LTS$ and a set $A$ of infinite initialised trajectories of $LTS$. If for all of the finite initialised trajectories of $LTS$ there exists an infinite trajectory in $A$ such that the finite trajectory is a prefix of the infinite one then we call $A$ \emph{machine-closed}. We define a \emph{trace} $\langle a_i \rangle_{i \geq 1}$ of (LTS,A) to consist of the labels from either a finite initialised trajectory of $LTS$ or a trajectory in $A$.
\end{mydef}
\medskip


\begin{mydef}[Trace semantics of hybrid automata]
All transitions of a timed transition system $S^t_H$ have an associated \emph{duration} $\delta \in R_{\geq 0}$. Every event $\sigma \in \Sigma$ the transition $q \xrightarrow{\sigma} q'$ has a duration of 0. For all transitions $q \xrightarrow{\delta} q'$ where $\delta \in R_{\geq 0}$ the duration is $\delta$.  We define an infinite trajectory $\langle a_i, q_i \rangle_{i \geq 1}$ of a transition system $S^t_H$ to be \emph{divergent} if the sum of the transitions $\Sigma_{i \geq 1} \delta$ is \emph{divergent}. For the set of divergent initialised trajectories $L^t_H$ of the timed transition system $S^t_H$, the hybrid automaton $H$ is \emph{non-Zeno} if $L^t_H$ is machined-closed for $S^t_H$.
 \end{mydef}

In other words automaton is \emph{non-Zeno} if for every possible state of the system reachable from the initial state by some finite trajectory that finite trajectory is the prefix of some infinite trajectory of the system that diverges in time. This means for instance that the system cannot alternate between two modes where the time between transitions infinitely decreases e.g. $\frac{1}{2}$,$\frac{1}{4}$,$\frac{1}{8}$,$\ldots$.

\section{Automaton Validation}
In the following we prove that the train automaton is non-Zeno i.e. that time can progress in every state of the system. We check that the automaton remains inside the regions defined by its invariants and does not become stuck on the edge of a region. This is important for verification purposes as simulations and model checking algorithms require the system to be live so that time can progress. In each of the proofs we perform a case by case argument for each control mode of the automaton. The proofs for the interlocking and radio block processor  automata are trivial since they do not contain any flow conditions or invariants and therefore it is not possible for the automata to enter a state in while time cannot progress. 

\subsection{Realistic Assumption}
For the automaton presented we cannot show that it  is non-Zeno as it is possible for movement authorities of an arbitrary length to be sent to the train automaton, which would allow the system alternate faster and faster between states. In practice this will not be the case as the RBC will extend the movement authority by a positive fixed length. \\
\begin{mydef}[Realistic Train Automaton]
We define a train automaton to be \emph{realistic} if its movement authority extensions form a finite set of positive numbers.
\end{mydef}
The smallest movement authority extension shall be used in the following proof. 
\\
\begin{mytheorem}[Realistic Train Automaton is Non-Zeno]
The realistic train hybrid automaton  $H_{T}$ is non-Zeno i.e. every finite initialised trajectory in the $LTS$ defined by the automaton has an infinite trajectory, of which it is a prefix, in the set of divergent initialised trajectories in the automaton.
\begin{proof}
Given a finite initialised trajectory, we perform a case distinction on the current case, i.e. the last state in the trajectory. We then prove that time can progress and that time is divergent separately.
\begin{description}
\item[Case: Stopped] There are no flows in this state, therefore invariant $S = 0$ cannot be violated. 

\item[Case: Accelerating] The invariant $\BD{S} \leq \DMA{D}{EoA}$ bounds the increase of the variables for the distance and speed which occur in this state resulting in two cases. The automaton is either in the region in which the invariant holds and can progress in time, or the automaton is at the boundary of the region defined by the invariant and time can no longer progress. When the automaton is at the boundary of the region $\BD{S} = \DMA{D}{EoA}$ holds and time can no longer progress in this control mode however a jump can occur to the Braking state in which the invariant $\BD{S} = \DMA{D}{EoA}$ holds. The invariant $S \leq MaxSpeed$ bounds the increase of the $S$ variable. In this state the speed will increase until the boundary of the invariant $S \leq MaxSpeed$ at which point time can not longer progress in the Accelerating state so the system must jump to the $Full Speed$ state.


\item[Case: Full Speed] 
The case for the $Full \, Speed$ state follows the same argument as the Accelerating state except for the part relating to the invariant $S \leq MaxSpeed$.

\item[Case: Braking]
The invariant $0 \leq S$ is the only invariant to bound the decrease of the speed in the Braking state. When the speed of  the automaton reaches zero, time can no longer progress in this state and the automaton is forced to perform a control mode jump to the stopped state. 
\end{description}

Time is divergent in at least one trajectory of the system because the movement authorities granted are always of a fixed length. This leads to a fixed set of trajectories from the moment at which a movement authority is received that must take a fixed length of time.

Initially the train is in the stopped state for some arbitrary length of time before receiving a movement authority. At this point, the hybrid automaton must jump to the accelerating state. From this state onwards there several possible control mode loops which the automaton must proceed through, each of which starts and ends with a movement authority being received. Each time the train enters one of these loops it spends a fixed amount of time in the accelerating and full speed states before braking.

\begin{itemize}
\item $Accelerating \to Braking \to Stopped \to Accelerating $
\item $Accelerating \to Braking \to Accelerating$
\item $Accelerating \to Full speed \to Braking \to Accelerating$
\item $Accelerating \to Full speed \to Braking \to Stopped \to Accelerating$
\end{itemize}


\end{proof}
\end{mytheorem}





\begin{comment}

We will now give a proof by induction that the safety condition "The train will always break on time" holds for a single train automaton.
The base case is that we are in the initial state, the stopped mode, with the invariant $D \leq EoA$. If are in the stopped mode and we receive a movement authority with $EoA > D$ then a jump is performed and move to the accelerating state. Since the transition of time does not cause any flow transitions to occur from the base case we do not need to consider it. In the step case we are in one of the 4 modes (Stopped,Braking,Accelerating,) with the invariant $BD(S) \leq DMA(D, EoA)$. In these states jump conditions are considered by performing a case distinction is performed on whether we reach the braking point i.e. $BD(S) = DMA(D, EoA)$ or we reach max the transitions result in states in which the invariants still hold. We also consider flow conditions, if time elapses by some amount $\delta$ we either reach the breaking point $BD(S) = DMA(D, EoA)$ and perform a jump into a state in which the invariant still holds or $BD(S) \leq DMA(D, EoA)$ in which case the invariant $D \leq EoA$ holds. 

Since we have restricted the movement authorities to occur at discrete intervals separated by $50$ units of distances we perform induction over the time interval $(0..1)$ in order to prevent multiple mode changes from occurring during the induction step. 
\medskip
\begin{mytheorem}
Given a live transition system $(S^t_{H_{T}},  L^{t}_{H_T}) $

 $$\forall \langle a_i, q_i \rangle_{i \geq 1} \in L^{t}_{H_T}.  \forall (a_n, (v, [D, EoA,S,\dot{S},TrainID])) \in \langle a_i, q_i \rangle_{i \geq 1}$$ $$ \to BD(S) \leq DMA(D, EoA)$$ 

under the assumption that the max S of the train and the track segment size (new MA increments) obey the following
                     $$max + max^2 < tsegsize$$
\begin{proof}


The proof is performed by fixing a trace $ \langle a_i, q_i \rangle_{i \geq 1}$ and  a label/state pair $(a_n, q_n)$ in the timed trace in which the property holds and then proving that the property holds for all possible successor label/state pairs $(a_{n+1},q_{n+1})$, where  the state $q_n = (v, [D, EoA,S,\dot{S},TrainID])$ and $q_{n+1} = (v', [D', EoA',S',\dot{S}',TrainID'])$ 

We begin by performing induction on the control mode of the system. 
There are 4 cases for $v$ in which we must argue that the transition $q_n \xrightarrow{a_{n+1}} q_{n+1}$  maintains the property $D \leq EOA$. We then perform induction on the time giving us a further two sub
cases in which the duration of the transition  $\delta = 0$ or $\delta \in \mathbb{R}_{>0}$



\begin{description}
\item[v = Stop] All possible transitions from the stop mode have a duration $\delta = 0$. There is one possible event that $MA.TrainID.y$ which will grant a new movement authority $y$ such that $EoA < y$ and cause a jump to the $Accelerating$ mode with $0 = BD(S) \leq  DMA(y,S') $


\item[v = Accelerating (Acc)] In the case that the duration of the transition is $\delta = 0$ and only control mode jumps caused by events can occur. The only one of these events that affects the invariant $BD(S) \leq DMA(D, EoA)$ is that a new movement authority is received $EoA'$ and since movement authorities are always incremented $DMA(D, EoA) < DMA(D, EoA')$.
  
In the case that $\delta \in \mathbb{R}_{< 0}$ then a flow transition has occurred and we are one of several
possible control modes depending on whether the transition of time triggered a jump or not.  The possibilities are as follows: \\

Acc: The train has accelerated and at not point in time has the distance become equal to the breaking distance therefore the current distance remains below the breaking distance. 


Acc $\to$ Brake: The train has transitioned between three states during the transition of $\delta$  . The transition to the breaking state was causes by the condition $BD(S(t_1)) = DMA(D(t_1), EoA)$ at some $t_1$ during the first duration in the Acceleration control mode which remains invariant during the Brake control mode 


Acc $\to$ Brake $\to$ Acc: The train has transitioned between three states during the transition of $\delta$  . The transition to the braking state was caused by the condition $BD(S(t_1)) = DMA(D(t_1), EoA)$ being met at some $t_1$ during the first duration in the Acc control mode which remains invariant during the Brake control mode. Then at another time $t_2$ the event MA.TrainID.EoA' occurs meaning a new movement authority has been granted EoA' such that $EoA + tsegsize \leq EoA'$ and the train transitions ot the Accelerating mode once again with the train travelling at $S(t_1)$.  At this point the invariant $BD(S(t_2)) \leq DMA(D(t_2), EoA')$ holds as we know previously at time $t_1$ that $BD(S(t_1)) = DMA(D(t_1), EoA)$ holds and since by the assumption $max + max^2 < tsegsize$ it is not possible for the train to travel an entire track segment and therefore $BD(S(t_3)) \leq DMA(D(t_3), EoA'')$ holds at all times $t_3$ in the second Acceleration control mode. 



 In the $Accelerating$ mode we have $\dot{S} = 1$ with $D \leq BD(EoA, S) \leq  EoA$. There are two cases either $D = BD(EoA,S)$ or $D < BD(EoA,S)$.  In the case that $D = BD(EoA,S)$  a jump occurs taking the system into the Braking mode
with $D(t_1) = BD(S,t_1) < EoA$. In the case that $D(t_1) < BD(S,t_1)$ time will progress and at some point in the future $t_2$ the train will with reach the braking point $D(t_2) = BD(S',t_2)$ or $S' = Max S \wedge (D(t_2) < BD(S', t_2)$.   In the case that $D(t_2) = BD(S', t_2)$ a jump will occur taking the train into the braking mode with $D(t_2) = BD(S',t_2) < EoA$. Otherwise $S = max$ and a jump is performed to the $Full Speed$ mode with $D(t_2) < BD(S', t_2) < EoA$.


\item[v = Full Speed (FAS)]
This is the same as  Accelerating, in the case that the duration of the trainsition is $\delta = 0 $. In the case that $\delta \geq 0$ mode have 4 possible cases 

FAS: The train is travelling at max and then condition $BD(S(t')) = DMA(D(t'), EoA)$ has not been met for all $t'$ in the real interval $\delta$. The invariant therefore continues to hold.

FAS $\to$ Brake: The time interval $\delta$ can be partitioned into two time intervals. The first ending at $t_1$ prior to which the system is in FAS and followed by the Brake mode which ends at $t_2$. The argument from the previous FAS case holds for the first time interval. The end of this time interval marks at point at which the condition $BD(S) = DMA(D(t_1), EoA)$ is met and for all subsequent points in time  the braking distance remains equal to the distance to the movement authority.. \\


FAS $\to$ Brake $\to$ Acc: The time interval $\delta$ can be partitioned into 3 time intervals. The first interval in which the system is in FAS ends at $t_1$, period in the Brake mode ends at $t_2$ and finally there is a period in the Acc Mode which ends at $t_3$. The argument for the time interval up to $t_2$ is the same as the argument for the previous FAS $\to$ Brake case. A new movement authority $EoA'$ is granted such that $ DMA(D(t_2), EoA) + 50 =  DMA(D(t_2), EoA')$ causing the jump from Brake to  Acc.  For the whole of the  time period spent in the Acc mode the invariant $D(t_3) < BD(EoA',S)$ holds as previously $BD(S) = DMA(DT(t_1), EoA)$ and it is impossible for the train to cover a distance of fifty in one time unit.


FAS $\to$ Brake $\to$ Acc $\to$ $FAS$: This follows the same argument as the previous however the time period has been partitioned into four instead of three. The invariant holds in the final FAS state for the same reason as the preceding Acc state as the control mode jump does not have any effect on the distance of the train.

wo cases  $D = BD(S, t)$ with $t = t_1$ or $t_2$,  $t_1 < t_2$. In the first case a jump occurs instantaneously to the $Braking$ mode with $D(t_1) = BD(S, t_1) < EoA$ In the second case time elapses to a point in the future $t_2$ and $D$ increases until $D(t_2) = BD(S, t_2)$  then the system will perform a jump to the $Braking$ mode with $D(t_2) = BD(S, t_2)  < EoA$. 


\item[v = Braking]
In the case that $\delta = 0$ there are no 

In the Braking mode with  $\geq \delta \geq 0$ we have $5$ possible cases depending on whether jumps have occurred between the different control modes.
In the Braking mode there are two cases either $MA.TID.y \wedge S > 0$ or $S = 0$. Since the train is braking by the definition of $BD$,  $D(t_2) \leq BD(S,t_2)$ will continue to hold for any amount of time in this state.  In the case that $MA.TID.y \wedge S > 0$ we receive a new movement authority $y$ with $y < EoA$ and a jump is performed to the $Accelerating$ mode with $D(t_2) \leq BD(S', t_2) < y$. In the case that $S = 0$ a jump occurs to the $Stopped$ state.


Braking: The first case is that we remain in the braking mode for the duration of the time interval. The invariant $BD(S) = DMA(D, EoA)$ holds for all times $t'$ in the duration of the interval of the as both the braking distance and distance decrease by the same amount over the time interval.

Braking $\to$ Stopped: The time interval $\delta$ can be partitioned into two separate intervals, the first ending at $t_1$ and the second ending at $t_2$, corresponding to the duration of time spent in the two control modes.  The argument for the first time interval  ending at $t_1$ is the same as that for the previous Braking case. 
The transition from the Braking to Stopped modes at $t_1$ is triggered by the S of the train reaching $0$. For all points in time $t_1'$ to and including this point in time the invariant $S(t_1') = DMA(D(t_1'), EoA)$ holds. For the remainder of the interval ending at $t_2$ the the train is stationary and the invariant continues to hold. By the first induction hypothesis



Braking $\to$ Stopped $\to$ Acc: In this case the time interval $\delta$ can be split up into three separate intervals, ending with $t_1,t_2$ and $t_3$  respectively, corresponding to the three control modes. The argument for the first two control modes is the same as the argument for the previous case. 
At the end of the interval $t_2$ a new movement authority $EoA'$ has been granted and all points in time $t_3'$ between $t_2$ and up to including $t_3$ the invariant $BD(S(t_3')) < DMA(D(t_3'), EoA')$ since the train has travelled at most one unit of distance during the interval and the movement authority has increased by 50.



Braking $\to$ Acc:  The time interval $\delta$ can be partitioned into two separate intervals, ending at $t_1$ and $t_2$ respectively, corresponding to the two control modes. The argument for the first control mode is same as that as the argument for the first Braking case.  At the end of the interval $t_1$ a new movement authority is received which greatly increases the braking distance far beyond what the train can travel in this possible time interval. By the first induction hypothesis since the invariant holds in any further control mode jumps


Braking $\to$ Acc $\to$ FAS: The time interval can be partitioned into three separate intervals ending at $t_1,t_2$ and $t_3$ respectively. The invariant holds in the first two time intervals following the argument from the previous case Breaking $\to$ Acc. At the end of the Acc mode there is a transition to FAS however since there is no possibility of the train reaching the breaking point we know that the invariant continues to hold.


\end{description}


Initially we are in the stop state and have $D \leq EoA$. There is only one possible transition from this state. we receive a new movement authority with $D < EoA$ and proceed to the accelerating state.
We have two possible cases from the accelerating state. The first case is that the train reaches the braking point and enters the braking state $D = BD(t,S)$. In this case the trains speed will decrease by -1 per unit of time and the train will enter the stop state $EoA$.
The second case is that the train reaches max S and goes into the max state. If the train reaches $D = BD(t,S)$ whilst in the max state then the train will go into the braking state and the same argument holds from the previous case.

\end{proof}

\end{mytheorem}


Another interesting property of our model is that alone the model of the interlocking allows for "jumping trains" i.e. it allows for track circuits to become free and occupied in a way that does not model the normal movement of trains.
However when the interlocking automaton is placed in parallel with a train automaton it behaves in a

\begin{mytheorem}

In the composite automaton $H_{IL}|| H_{T} $  the event $t_x.t_{x+1}$ will only occur if  and only if$t_x$ is currently occupied in which case $t_x'$ = free and $t_{x+1}' = occupied$.


\begin{proof}
We have to prove the two directions of the statement. First we prove the $\to$ direction.




Assume a train is in $t_x$ and $((x-1) \ ,mod 5) * 50 \leq D < x *50$.

There are two cases
\begin{enumerate}
\item If the train is in the Stopped state then a $t_{x}.t_{x+1}$ event will never occur as it is not possible in this state.

\item The train is moving i.e. it is in either of the $Accelerating, \, Braking , \,  Full \, Allowed \, S$ states. In this case the position of the train will be increasing and eventually it will happen that $D \,  mod \, 50 = 0$. When since $D \, mod \, 50 = 0$  satisfies the jump condition the event
 $t_{x}.t_{x+ 1}$ will occur.  
 

\end{enumerate}
\end{proof}
\end{mytheorem}
\end{comment}

%%%\section{Conclusion}


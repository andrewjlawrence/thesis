\newcommand{\rtmaude}{Real Time Maude}

\thesischapter{The Modelling of the European Rail Traffic Management System Using Real Time Maude}




In the following we present the Maude \cite{MC03,Maude} and Real Time Maude \cite{PO02,PO04,RTMaude} tools and describe an approach using these tools to model the ERTMS system (See chapter \ref{chapter:ERTMS}).   We begin by giving a general introduction to Maude and Real Time Maude and then describing how each of the 3 subsystems (trains, the interlocking and the RBC) are specified following the hybrid automata formalisation found in chapter \ref{chap:hybrid}. Each of these individual components are modelled using object orientated specification. We define classes representing each of the subsystems and then rewrite rules are used to give objects from these classses behaviour. The  built-in message construct of the Real Time Maude system are used to define communication between the subsystems.




\subsection*{Related Work}
The Maude System has been used for a variety of specification and verification tasks. Hardware such has microprocessors has been specified and verified \cite{NH00}. A distributed sensor network employing the OGDC algorithm has been modelled and verified using Real Time Maude \cite{PO07}. The modelling of the progression of time over the sensor network has inspired the distribution of in our ERTMS model. The Real Time Maude system can also be used for simulation and analysis of systems as seen in the work on the CASH Scheduling Algorithm \cite{PO06}. 

On the front of hybrid automata, ETCS has been verified in the form of Hybrid Automata by translating the automata into a program and then performing model checking using the post condition calculus \cite{DI13}. The Hi-Maude system \cite{MF11} is an extension of Real Time Maude designed specifically modelling interacting hybrid systems and as such it can handle differential equations. It has been used in a case study to model the effects of extreme heat on the human body \cite{MF12}. It is geared towards systems of a highly dynamic nature and may be overkill for a system such as ERTMS with a large discrete component.


There have been several attempts to model and verify parts of the ERTMS system. The scale of the system and differences in implementations from one country to another both make its formalisation challenging. A subset of the systems requirements specification of ERTMS in UML consisting of high level discrete modes and transitions was captured, formalised and verified using the SMV model checker \cite{MG14}. A variety of properties were checked including safety and liveness which were formalised using modes of the system. One safety condition  "the ETCS on-board never leaves the TRIP mode (TR) before the driver has acknowledged the trip and the train has stopped"\footnote{a train enters the TRIP mode after it has over run its stopping point.}, was formalised as an LTL formula with a boolean variable to represent that the train has stopped, it was then successfully verified using SMV. Our work attempts to capture the more concrete behaviour of the overall system including the physical behaviour of trains such as their speed and that of the highly safety critical interface between ERTMS and the interlocking. 

There has been a large amount of work on the modelling and verification of ETCS using differential dynamic logic \cite{AP08} in the Keymaera tool \cite{AP08b}. The RBC handover where a train moves from the area governed by one RBC into another has been modelled in \cite{YL11}. The properties proven in this study include non-derailment and non collision of trains which follows from correct handover and new movement authority generation. ETCS \cite{AP09} itself has been modelled as a dynamical system with external disturbances and verified for safety in terms of collision avoidence, liveness, controlability and reactivity.

There are also several model checkers specifically for the verification of hybrid systems, including HyTech \cite{AR96} and PHAVer \cite{GF05}, which perform an exhaustive search of the state space to check that a given property holds.

\section{Maude}
In the following section we shall describe the term rewriting system Maude. It is a multi-purpose tool containing support for executable-specification, simulation and verification of systems and software. We make use of all 3 of these capabilities and it is this wide range which draws us towards its use. In order to full understand its use in the specification of a real time system we first present a formal and informal definition of a Maude specification followed by an example Maude specification to give insight into theses definitions.



\subsection{Maude Specifications}

A Maude specification consists of \emph{functional modules} declared using \texttt{fmod} and \texttt{endfm} which contain the following:

\medskip
\begin{center}
\begin{tabular}{| c | l |}
\hline
sorts    & \texttt{sort} $s$ or \texttt{sorts}  $s \ s' .$ \\ \hline
subsorts  & \texttt{subsort} $s < s' \ .$ \\ \hline
function symbols  & \texttt{op} $f \ :  \ s_1 \ldots s_n$ \texttt{->} $s \ .$ \\ \hline
variables  & \texttt{vars} $v \ v' : s' .$\\ \hline
uncondition equations  &\texttt{eq} $t = t' .$\\ \hline
condition equations & \texttt{ceq} t = t' \texttt{if} $cond$ \\ \hline
membership axioms & \texttt{mb} $t \ : \ s \ .$ or \texttt{cmb} $t  \ : \ s$ \texttt{if} $cond \ .$  \\ \hline
\end{tabular}
\end{center}
\medskip
The data types of a Maude specification are defined using sorts with subtypes expressed as subsorts. Terms are constructed using function symbols and variables which are then  given behaviour using equations and conditional equations.  A maude specification is executed by rewriting, that is the system repeatedly applys rewriting rules to a term until the term can no longer be rewritten.

%%% Read the Maude papers as this is currently very close to the description of a maude specification found in the RT maude theory paper.
\medskip
\begin{mydef}[Equational Theory]
An equational theory is a 2 tuple $(\Sigma, E)$ where $\Sigma$ is a set of sorts, subsorts and operator declarations  and $E$ is the set of equations modulo $\Sigma$
\end{mydef}

Equational theories  form the signature of a Maude specification and provides one with a means to represent data types using various symbols. If we consider the natural numbers defined symbolically  as an equational theory, the set $\Sigma$ would consist of the sort $Nat$ and the operations $0$, $s$, and $+$, the set $E$ would consist of associativity and commutativity for $+$.

Formally a Maude specification is a \emph{rewrite theory} of the form $\mathfrak{R}=(\Sigma,E,L,R)$, where  $(\Sigma, E)$ is an equational theory, $L$ is a set of labels and $R$ is a set of labelled rewrite rules of the form:

$$ [l] : t \to t' \ \mathbf{if} \bigwedge^{n}_{i = 1} u_i \to v_i \bigwedge^{m}_{j = 1} w_j = w'_j $$

where $l$ is a label $l \in L$ and $t$, $t'$, $u_i$, $v_i$, $w_j$ and $w'_j$ are implicitly universally quantified variables representing $\Sigma$-terms. Maude theories are \emph{order-sorted} allowing for the specification of subsorts which is achieved by including into the specification a partial order relation over sorts. Given two sorts $s$ and $s'$ this partial order relation $s \leq s'$ is interpreted as subset inclusion $A_s \subseteq A_{s'}$ in a model $A$.

The behaviour of the operations defined in an equational theory are defined in a rewrite theory using the labelled rewrite rules. In the case of the natural numbers it is then possible to provide an definition for $+$ recursively. The base case is where 0 is one of the operands in which case we return the other $0 + N \to N$. The successor case is that we have some non-zero operand represented as a successor to some variable $s(M)$ in which case we apply the successor function to the recursive call of addition with M and the other operand $s(M) + N \to s(M + N)$. 
 

\subsubsection{Example Maude Specification}
We shall now give a small example specification in the form of the natural numbers in Maude in order to get a feel for the structure of such a specification. We see that the module BASIC-NAT is declared on the first line of the example (Code listing \ref{code:natnum}). Followed by a sort Nat which forms the type with which we will be working. Next several operations are declared which we use to define the natural numbers symbolically. Firstly, we see the 0 operator which forms our base constructor which is followed by another operation s which allows us to construct successive natural numbers. The addition operation $+$ is defined to be infix using variable place holders represented by an underscore in the declaration  $\_$. The behaviour of the addition operation is defined inductively using two variables N and M and two equations for the base and successor cases. In the base case is that zero added to any natural number results in that natural number. The successor case is that given a successor of some natural number $M$ that number can be added to a number $N$ by taking the successor of $N+M$.

\begin{lstlisting}[caption = The natural numbers in Maude, label = code:natnum]
fmod BASIC-NAT is
        sort Nat .

        op 0 : -> Nat .
        op s : Nat -> Nat .
        op _+_ : Nat Nat -> Nat .

        vars N M : Nat .

        eq 0 + N = N .
        eq s(M) + N = s(M + N) .
endfm
\end{lstlisting}



\section{Real Time Maude}
One extension of Maude that can be used to model and verify hybrid systems is Real Time Maude. It contains specific support enabling the modelling and verification of real-timed and discrete timed systems. 
The Real Time Maude system contains a general theory for time and several specifications of time, including discrete time based on the natural numbers and dense time based on the rationals, that implement that theory.

\subsection{Real Time Maude Specifications}
A Real Timed Maude specification consists of \emph{timed modules} that start with \texttt{tmod} and end with \texttt{endtm}. Formally a Real Time Maude specification is a real-time rewrite theory which can be thought of as a rewrite theory with an interpretation for the abstract time domain together with rewrite rules for terms of type \texttt{System} that have a time duration \cite{PO02}. These rewrite rules can be separated into two categories, the \emph{tick} rules have a non-zero time elapse and the \emph{instantaneous} rules have a time elapse of zero.

The interpretation of the abstract time domain is mapped to a concrete specification of time during the specification process. Real time Maude comes with two of these specifications as standard the most simple  is discrete time based on the natural numbers and the more complicated of the two is dense time based on the rational numbers. We shall use discrete time for the specification which will result in a smaller state space and therefore better model checking results during the verification process.
\medskip

\begin{mydef}[Equational Theory Morphism]
 We define an \emph{equational theory morphism} $H: (\Sigma,E) \to (\Sigma', E')$ to consist of the following
\begin{itemize}
\item a monotone map $H:sorts(\Sigma) \to sorts(\Sigma')$ which maps  sorts in $\Sigma$  to sorts in $\Sigma'$

\item a mapping which maps every function symbol $f : s_1 \ldots s_n \to s$ in $\Sigma$ to some term $H(f_{s_1 \ldots s_n, s})$ from $\Sigma'$ of sort $H(s)$ such that the following conditions are satisfied:
\begin{enumerate}

\item  $\var{H(f_{s_1 \ldots s_n, s})} \subseteq {x_1:H(s_1), \ldots, x_n:H(s_n)}$

\item If the operator $f: s_1 \ldots s_n \to s$ can be subsort overloaded $f: s'_1 \ldots s'_n \to s'$ such that $s_i \leq s'_i, s\leq s'$ then it is possible to substitute each variable $x_i:H(s'_i)$ by the corresponding variable $x_i:H(s_i)$ in the term $H(f_{s'_1 \ldots s'_n, s})$ and obtain $H(f_{s_1 \ldots s_n, s})$.

\item For every axiom: $$(\forall y_1:s_1, \ldots y_k : s_k) u = v \ \textbf{if} \ C$$ in E the homomorphic extension of $H^*$ to terms and equations in the condition $C$ causes the following to hold:
   $$E' \models (\forall y_1 : H(s_1), \ldots, y_k : H(s_k)) H^*(u) = H^*(v) \ \textbf{if} \ H^*(C)$$
\end{enumerate}

\end{itemize}

\end{mydef}
\medskip

A real time rewrite theory is a rewrite theory combined with some concrete implementation of time based on the abstract time domain defined in the time theory. The equational theory morphisms are used to map objects and morphisms in the abstract time domain to the concrete implementation.

\medskip
\begin{mydef}[Real-Time Rewrite Theory]
We define a \emph{real-time rewrite theory} $\mathfrak{R}_{\phi,\tau}$ to be a tuple $(\mathfrak{R}, \phi,\tau)$ containing a rewrite theory $\mathfrak{R} = (\Sigma, E,L,R) $ where:

\begin{itemize}
\item $\phi$ is an equational theory morphism $\phi : \mathit{Time} \to (\Sigma, E)$ that maps objects in the theory \textit{Time} to objects in the equational theory $(\Sigma , E)$.

\item The time domain is functional i.e. if a term $r$ of sort $\phi(Time)$  has a rewrite proof $\alpha: r \to r'$ then $r = r'$ and the identity proof of $r$ is equivalent to $\alpha$.

\item There is a designated sort typically called \textit{State} and a sort \textit{System}, contained within $(\Sigma, E)$, which has no supersorts or subsorts and only one operator that does not satisfy any non trivial equations:

$$\{\_\}: State \to System$$

Further to this condition, it is all required that the sort \textit{System} does not appear in $s_1, \ldots s_n$ the domain  of  any operator $f: s_1, \ldots s_n$.

\item For each rewrite rule with $u$ and $u'$ of sort \textit{System} in $\mathfrak{R}$ of the following form\footnote{All other rules which are not of this form are called \emph{local} rules and have an instantaneous zero time elapse. These do not act on the system as a whole but rather on one or more of its components.}:
$$[l]: u(x_1,\ldots ,x_n) \to u'(x_1,\ldots ,x_n if C(x_1, \ldots ,x_n) \ \textbf{if} \ C(x_1, \ldots ,x_n)$$


there is an assigned term $\tau_l(x_1 \ldots x_n)$ of sort $\phi(Time)$ within $\tau$.

\end{itemize}
\end{mydef}
 
\subsubsection*{Example Real Time Maude Specification}
The following a very simple model of a train Real Time Maude that moves one unit of distance in one time unit along a circular track of length 500. It defines a sort \texttt{TrainState} and a single state \texttt{move}. We have a constructor train of type \texttt{System} which consists of a train state and a natural number.  

\begin{lstlisting}
(tmod DISCRETE-SINGLE-TRAIN is protecting NAT-TIME-DOMAIN .
  sort TrainState .
  ops  move :  -> TrainState [ctor] .
  op train : TrainState Nat -> System [ctor] .
 
  vars N : Time .
  crl [travel] : {train(move,N)} => {train(move,N + 1)} 
                                      in time 1 if N < 500 .
  rl [reset] : {train(move,500)} => {train(move,0)} . 
         
endtm)
\end{lstlisting}
There is a condition rewrite rule called travel which enables the train to move as long as its current distance is less than 500. There is a reset rule that instantaneously resets the trains distance back to zero when it reaches 500.


\subsubsection*{Executing a Real Time Maude Specification}
Real Time Maude allows one to execute or simulate a real time system by applying rewriting rules to a term of type \texttt{System}.
The command \texttt{(trew \{System\} in time <= t)} will attempt to rewrite the system to a state $t$ time units in the future. This is not always possible though as the system may deadlock. The following command attempts to rewrite a train, which initially has distance $0$, to its state in 100 units of time in the future: 
\begin{center}
\texttt{(trew {train(move,0)} in time $\leq$ 100 .)}
\end{center}

The result from this timed rewrite is as follows:
\begin{lstlisting}
rewrites: 4027 in 4ms cpu (3ms real) (1006750 rewrites/second)

Timed rewrite  {train(move,0)} in DISCRETE-SINGLE-TRAIN 
with mode deterministic time increase in time <= 100

Result ClockedSystem :
  {train(move,100)} in time 100
\end{lstlisting}

The ability to perform such simulations is useful as it allows for the liveness of a system to be checked. It also provides another way of validating the correctness of a model by perform many of these executions and checking the behaviour of the system over time.

\subsection{Object Orientated Specification in Real Time Maude}
Real Time Maude is based on Full Maude which contains message and object constructs for object orientated specification. Using these constructs its possible to model ERTMS as several synchronously communicating processes. A Real Time Maude specification consists of  \emph{timed object orientated modules} which start with \texttt{tomod} and end with \texttt{endtom}.
\medskip
We can define the following:
\begin{align*}
\textbf{classes}: & \texttt{ class C | a1 : ⟨Sort-1⟩, ... , an : ⟨Sort-n⟩ . } \\
\textbf{objects}: & \texttt{ < O : C | a1 : v1, ... , an : vn >  . } 
\end{align*}
where $C$ is the class identifier $O$ is the object name  $a_1 \ldots a_n$ are attribute names and $v_1 \ldots v_n$ are values. \\
\medskip
\subsubsection*{Messages}
To model communicating processes Real Time Maude uses a messages construct:
\begin{center}
\verb|msgs M1 ... Mn : Sort-1 ... Sort-n -> Msg . | 
\end{center}

The message construct acts as a container for data being pased between different communicating sub systems. Rewriting rules are used to capture the behaviour of sending and receiving messages between different objects.

\subsubsection*{Configurations in Real Time Maude}
Objects and messages in a specification are given a sort of \texttt{Configuration} which is a subsort of type \texttt{System}. The composition operation for configurations allows for a combination of objects and messages to form new configurations. This composition operation is also commutative meaning that the order of messages and objects in any configuration is ignored. This allows for more generalised rewriting rules in an object orientated specification that speak about specific objects and messages that are part of some bigger configuration as the order does not affect the firing of the rule.

\begin{lstlisting}[caption = The Maude Configuration module]
mod CONFIGURATION is  
    *** basic object system sorts  
    sorts Object Msg Configuration .  
 
    *** construction of configurations  
    subsort Object Msg < Configuration .  
    op none : -> Configuration [ctor] .  
    op __ : Configuration Configuration -> Configuration  
         [ctor config assoc comm id: none] .
\end{lstlisting}

\subsubsection*{Example Object Orientated Specification}
The following is an example consisting of two classes of object which serves to demonstrate some of the advantages of object orientated specification as well as some of the pit falls. Firstly there is the class defining D objects which count modulo 500 and transmit a message containing the current count. Secondly there is class defining a object B that reads messages from a D object. 

\begin{lstlisting}[caption = Example object orientated specification, label = code:rtmaudeexample]
(tomod EXAMPLE1 is protecting NAT-TIME-DOMAIN .
  msgs msgD  : Nat -> Msg .  
  class  D | d : Nat .
  class  B | b : Nat .
  vars N: Nat .
  var O : Oid .
  var REST : Configuration .
 
  rl [makeD] : {< O : D | d : N > REST} => 
  {msgD(N + 1 rem 500)  
  < O : D | d : (N + 1) rem 500 > REST} in time 1 . 

  rl [readB] : {msgD(N) < O : B | > REST} => 
  {< O : B | b : N > REST}  . 
endtom)
\end{lstlisting}

We can execute a system consisting of a D  and a B object for 2 times steps using the following command:
\begin{center}
\texttt{(trew {< myD : D | d : 0 > < myB : B | b : 0 >} in time <= 2 .)}
\end{center}

Resulting in the following output:
\medskip
\begin{lstlisting}
rewrites: 6246 in 7ms cpu (7ms real) 
(805000 rewrites/second)

Timed rewrite  {< myD : D | d : 0 > < myB : B | b : 0 >} 
in EXAMPLE1 with mode deterministic time 
increase in time <= 2

Result ClockedSystem :
  {< myB : B | b : 2 > < myD : D | d : 2 >} in time 2
\end{lstlisting}

The Maude system rewrites the initial state of the system into the resulting state however that does not mean that this is the only reachable state. This set has some non-determinism in that we do not force the messages to be read immediately and the rewriting equations could be applied in any order. There is a reachable state in time 2 in which both of the messages have not been read meaning that either of them could be read in any order resulting in  . 
The following are some states reachable in time 2.

\begin{lstlisting}[caption = Some of the states reachable by rewriting EXAMPLE1 in two time steps, label = code:reachst ]
{< myB : B | b : 1 > < myD : D | d : 2 >}
{< myB : B | b : 2 > < myD : D | d : 2 >}
{msgD(1)< myB : B | b : 2 > < myD : D | d : 2 >}
{msgD(1)msgD(2)< myB : B | b : 0 > < myD : D | d : 2 >}
{msgD(2)< myB : B | b : 1 > < myD : D | d : 2 >}
\end{lstlisting}

\emph{Non-determinism} should be avoided unless it is really is a property you want in a model. One way to remove some of these reachable states is to make the variable \texttt{REST} of sort \texttt{ObjectConfiguration}. This forces objects of the B class to read messages after each incrementation of time. If we make this modification to the specification then the following states, from code listing \ref{code:reachst}, are reachable in time 2.
\medskip
\begin{lstlisting}[caption = States reachable by the modified EXAMPLE1 in two time steps]
{< myB : B | b : 2 > < myD : D | d : 2 >}
{msgD(2)< myB : B | b : 1 > < myD : D | d : 2 >}
(msgD(1)< myB : B | b : 0 > < myD : D | d : 1 >}
(< myB : B | b : 1 > < myD : D | d : 1 >}
\end{lstlisting}

\section{Modelling the European Rail Traffic Management System}
In the following we shall give an overview of the specifications used to model the ERTMS system. We have used the Real Time Maude system in an object orientated fashion following the hybrid automata described in chapter \ref{chap:hybrid} to define one class for each of the 3 hybrid automata. Time has been modelled by the use of a function $\delta$ that distributes the transition of time over objects in the system. Rewriting rules are then applied to $\delta$ containing singleton objects to give each individual object its behaviour. We attempt to remove as much non-determinism from the model as possible by forcing the ERTMS system to read all messages by the end of each time step and by preventing trains from making more than one movement authority request to the radio block processor in a given timestep.


\subsubsection*{Modelling the Transition of Time}
In our previous Real Time Maude specifications we have had a rewrite rules that work on a specific object or state and increment time for the whole system. This presents a problem as we could have two objects that can both increment the time of the global system independently.  Since we are modelling a real life system all of the subsystems much be subjected to time in an equal manner. We need a way of incrementing the time of the whole global system and then distributing this increment of time amongst the objects of the system. To solve this problem we define operator $\delta$ which describes how distributed system evolves with time.

\begin{lstlisting}[caption = The delta time transition operation, label = code:delta]
op delta : Configuration -> Configuration [frozen] . 

var OCREST : ObjectConfiguration .

rl [timetrans] : {OCREST} => {delta(OCREST)} in time 1 .
rl [delta1] : delta(CON1 CON2) => delta(CON1)delta(CON2) .
\end{lstlisting}

The operation $\delta$ is frozen meaning that the configuration contained within will not be evaluated by the Maude until the $\delta$ operation has been evaluated. We only allow for time to be incremented on a global system containing an object configuration which cannot by definition contain any messages. This forces all messages sent in one time interval to be read during that interval. The delta1 rule distributes the delta operation over the constituent objects of a configuration until there are many deltas applied to configurations containing singleton objects. Each of these singleton objects has its own seperately defined behaviour for the delta operation that captures that transition of time for that object. This was inspired by  \cite{PO07} where a delta operation is used to distribute time over a distributed sensor network. 

\subsubsection*{Modelling Trains}
We shall now describe the specification of trains. We define the Train class to have a state which like our hybrid automata can be in one of 4 possibilities, constant speed, accelerating, stopped and breaking. As well as the state it also has 6 fields of sort Nat representing the distance, speed, acceleration, movement authority,  current track segment and max speed.

\begin{lstlisting}
sort TrainState .
ops  cons acc stop break :  -> TrainState [ctor] .

class Train | state : TrainState, dist : Nat, 
      speed : Nat, ac : Nat, ma : Nat, 
      tseg : Nat, maxspeed : Nat .
\end{lstlisting}

We capture the behaviour of trains using a number of instantaneous and tick rewriting rules. The instantaneous rules are used to capture a change of state within a train. For example if the a train is in the cons state distance to the movement authority becomes less than the distance needed to break to zero in the next moment of time one of these rules will fire and cause a state transition. 

We compute the breaking distance as follows: 
\begin{center}\texttt{eq bd(S) = (S * S) div 2 .}\end{center}


The division operation is based on repeated subtraction and finally taking the floor or the resulting number. When we divide a number by two in the breaking function we add 1 to change this to the ceiling of the resulting number. This prevents a situation where we have a distance of 1 from our moment authority but the breaking distance is zero.
The distance to the movement authority to the train is computed by:
\begin{center}
\texttt{} \\
\texttt{}
\end{center}

In this Maude specification the jumps from accelerating and full speed states to the braking state occur when the braking distance becomes less than the distance to the end of the movement authority in the next moment of time.  The transition of the train one from track segment to another is captured by applying an operation $\textbf{trackseg}$ to the train after every increment in time. The $\textbf{trackseg}$ operation computes whether a track segment transition has occured, if it has then a message is sent to the interlocking to update its track segment variables accordingly.

\subsubsection*{Sets and Maps in Maude}
In order to have more general data types Maude allows for parametrised functional modules with the  syntax \texttt{fmod M{$X_1$ :: $T_1$ , $\ldots$ , $X_n$ :: $T_n$} is $\ldots$ endfm} where $n \geq 1$, $X_1$ is the \emph{parameter name} and $T_1$ is the \emph{theory name}.

In the formalisation of the RBC we make use of the Map data type to store the position and movement authority of a given train and we use a Set to store trains that have made requests in the current time interval. 

\begin{lstlisting}[caption = The specification of the Set data type in Maude]
fmod SET{X :: TRIV} is 
 protecting EXT-BOOL .
 protecting NAT .
 sorts NeSet{X} Set{X} .
 subsort X$Elt < NeSet{X} < Set{X} .

 op empty : -> Set{X} [ctor] .
 op _,_ : Set{X} Set{X} -> Set{X} .
 
 op insert : X$Elt Set{X} -> Set{X}
 eq insert(E, S) = E, S

 op _in :: X$Elt Set{X} -> Bool .
 eq E in (E, S) = true.
 eq E in S = false [owise] .

\end{lstlisting}

The indivudal elements the set are themselves are a subsort of set, allowing for sets to be constructed using the union operater \texttt{\_,\_} and singleton sets. The in operation computes set membership and is based on the \texttt{otherwise}  meaning that false case will only be applied once the search for true case has been exhausted.

\begin{lstlisting}[caption = The specification of the Map data type in Maude]
fmod MAP{X :: TRIV, Y ::  TRIV} is
 protecting BOOL .
 sorts Entry{X,Y} Map{X,Y} .
 subsort Entry{X,Y} < Map{X,Y} .

 op _|->_ : X$Elt Y$Elt -> Entry{X,Y} [ctor] .
 op empty : -> Map{X,Y} [ctor] .
 op _,_ : Map{X,Y} Map{X,Y} -> Map{X,Y} 
     [ctor assoc comm id: empty prec 121 format (d r os d)] .
 op undefined : -> [Y$Elt] [ctor] .

 var D: X$Elt .
 vars R R' : Y$Elt .
 var M : Map{X,Y} .

op insert : X$Elt Y$Elt Map{X,Y} -> Map{X,Y} .
eq insert(D, R,(M, D |-> R'))
   = if $hasMapping(M, D)
    then insert(D, R, M)
    else (M, D |-> R)
    fi .
eq insert(D, R, M) = (M, D |-> R) [owise] .

op $hasMapping : Map{X, Y} X$Elt -> Bool .
eq $hasMapping((M, D |-> R), D) = true .
eq $hasMapping(M, D) = false [owise] .

op _[_] : Map{X,Y} X$Elt -> [Y$Ellt] [prec 23] .
eq (M, D |-> R) [D]
   = if  $hasMapping(M, D) then undefined else R fi .
eq M[D] = undefined [owise] .
\end{lstlisting}
A Map from type $X$ to type $Y$ consists of entries constructed using the $\_|->\_$ operation on an element of type $X$ and an element of type $Y$. These entries are composed together using the commutative and associative opertation $\_,\_$ to form a Map.  

When we use a parametrised data type in a specification it is possible to assign a new sort to the particular parametrised instance of the map or set that we are using.
\begin{center}
\texttt{protecting MAP\{Oid,Nat\}  * (sort Map\{Oid,Nat\} to MapON,
                               sort Entry\{Oid,Nat\} to EntryON) .}
\end{center}




\subsubsection*{Modelling the Radio Block Processor}
The RBC is slightly differently from the hybrid automaton described previously. Instead of having four states the RBC has three states with the behaviour of the granted state being combined into the behaviour of a transition which causes the RBC to leave the wait state. The when the RBC receives a track segment grant fromt the interlocking it immediately grants the movement authority before going back to the idle state.
 
\begin{lstlisting}[caption = The RBC state and class definition in Maude]
sort RBCState .
ops rbcidle ready wait :  -> RBCState [ctor] .
class RBC | state : RBCState, lasttrain : Oid, ma : MapON, 
      pos : MapON , curreq : SetO .
\end{lstlisting}

We use maps to store the current movement authorities and positions of the various trains. In order to prevent an infinite amount of requests being made to an interlocking we limit the rbc to make one request on behalf of each train to the interlocking.  To do this we use  \texttt{curreq}, a set of oids, to store which trains have had a request made for them at a given moment of time.

An example RBC transition is as follows:
\begin{lstlisting}[caption = The state transition for the granting of a movement authority]
rl [rbcgrant] : {grant(N) < O : RBC | state : wait, 
   lasttrain : T1, ma : MAP1  > REST} => 
   { < O : RBC | state : rbcidle, 
       ma : insert(T1,endoftrack(N),MAP1) > 
     grantma(T1, endoftrack(N)) REST} .
\end{lstlisting}

This transition captures two of the state transitions in our RBC automaton. Once the interlocking has granted a request to the RBC for track segment $N$ the RBC immediately proceeds to simultaneously update the movement authority mapping entry for that train and issues a \texttt{grantma} message to that train with a new movement authority for the end of track segment $N$.

\subsubsection*{Modelling the Interlocking}
An interlocking has two states, either it is idle or it has received a request for a movement authority and must respond. We define an Interlockings state and class in Real Time Maude as follows:

\begin{lstlisting}[caption = The interlocking class and states in Maude]
sort InterState .
ops idle res :  -> InterState [ctor] .
class Inter | state : InterState, reqid : Nat, 
      t0 : Bool, t1 : Bool, t2 : Bool, 
      t3 : Bool, t4 : Bool .
\end{lstlisting}

The sort \texttt{InterState} models the state of the interlocking along with two constant operations idle and res which represent the two states. The interlocking class consists of a interlocking state, a request id which stores the current track segment requestions and 5 Booleans which indicate whether or not a track segment is occupied. We define an Interlocking class in Real Time Maude as follows:


All of the rewrite rules on Interlocking objects are instantaneous and do not effect the transition of time.  We can split these rules into two types. Firstly there are interlocking rules that deal with the transition of a train from one track segment to another. Secondly there are several rewriting rules that deal with granting or denying a received request. There is currently a rule for both denying and granting a request for each track segment depending on the value of the boolean variable.

\begin{lstlisting}[caption = The interlocking transition which grants a track segment request]
rl [resreq1g] : {< O : Inter | state : res, t
   1 : false,  reqid : 1 > REST} => 
   {< O : Inter | state : idle > grant(1) REST} .
\end{lstlisting}

\section{Extension to a Small Junction}
The modelling approach used to model the pentagon example (see fig. \ref{fig:pentagon2}) has been extended to model a small junction (see fig.~\ref{fig:junctionexample}). The main differences with the previous approach is that this junction is an open track and therefore the trains have the ability to enter and exit. To capture this we have specified a controller object which contains a schedule of the trains to enter the track. This object negotiates the joining of the trains to the track with the RBC. It also has two routes for the trains to follow and the interlocking and RBC have been modified to capture this behaviour.  In Chapter \ref{} we will use the Maude LTL model checker to verify the safety condition "A point does not move if it is in a movement authority".
 
\subsection*{Junction Example}
The junction example consists of one point, two routes, seven track segments, a controller object to schedule trains, an RBC and an interlocking.

\begin{figure}[h!]
\begin{center}
\begin{tikzpicture}[node distance = 3cm]
\draw (0,0) -- (10,0);
\foreach \n in {1,...,5} {
  \pgfmathtruncatemacro{\valuem}{(\n - 1)};
    \node () [above] at (\n *2 -1,0) {$l_{\valuem}$};
}
\foreach \n in {2,...,5} {
  \pgfmathtruncatemacro{\valuem}{(\n - 1)};
    \draw (\valuem *2, -0.125) -- (\valuem *2, 0.125) ;
}
\draw (4.5,-0.2) -- (5.2, -0.2);
\draw (5.2,-0.2) -- (8,-3);
\draw (5.575,-0.825) -- (5.825,-0.575);
\draw (6.725,-1.975) -- (6.975,-1.725);
\draw (8.125,-2.875) -- (7.875, -3.125);
\node () [] at (6.6,-1.05) {$l_5$};
\node () [] at (7.7,-2.15) {$l_6$};
\draw [->,dashed] (0,1) -- (10,1);
\node () [above] at (5,1) {Route 1};
\draw[dashed] (0,-1) -- (4,-1);
\draw[->,dashed] (4,-1) -- (6,-3);
\node() [below] at (3,-1.2) {Route 2};
\end{tikzpicture} 
\end{center} 
\caption{Junction Example}
\label{fig:junctionexample}
\end{figure}

\subsection*{The Controller Object}
The open ended nature of the junction example requires an object to act as a scheduler. This role is fulfilled by the controller class. 

\begin{lstlisting}[caption = "Controller Class"]
class Controller | 
      trainorder : ListT, trainmax : MapON, trainroute : MapON .
\end{lstlisting}

The controller class contains 3 parameters which are used to store a list of trains that are going to enter the track. The first parameter \textbf{trainorder} stores a list of object identifiers that are used to name trains whilst the order of the list corresponds to the order in which the trains are added to the track. The other two parameters of the controller class are both mappings from object identifiers to natural numbers. These mappings \textbf{trainmax} and \textbf{trainroute} are used to store the two parameters needed to create the train class namely the trains maximum speed and its route.

The controller object makes one join request, using a \textbf{reqjoin} message containing the object identifier of the first train in the trainorder list and its associated route, to the RBC per unit of time . If this request is granted then the first object identifier in the trainorder list is removed and a new train object is created with that object identifier with its maxspeed and route obtained from the mappings in the controller object. The speed and distance of the new train are both set to zero and a message is sent to the interlocking indicating that the initial tracksegment is now occupied. 

\subsection*{Modified Trains, Interlockings and Radio Block Processors}
The component classes from the pentagon example have been modified to capture the behaviour of a junction.  The train class has seen the least modification, with only one additional parameter route which stores a natural number corresponding to the trains route. The RBC class has been modified to include a additional mapping from object identifiers to the natural numbers that contains the route of each train. The number of states of an RBC has increased from 3 to 4 with an extra state $\mathbf{waitjoin}$ capturing that a join request has been made. When a join request is made the RBC checks to see if the route requested is currently set. If the route requested is set and the initial track segment is clear then the join request is accepted. If the route is not set then the RBC checks with the interlocking that it can set the route. This requires that the first 3 track segments are clear in order to change the direction of the point. The interlocking class has been modified to capture both the behaviour of the point and the addition of join requests. The point is modelled in the interlocking as two boolean variables $\mathbf{p1n}$ which indicates that the point is driven normal and $\mathbf{p1r}$ which indicates that the point is driven in the reverse direction.
%
The RBC has been modified to process any requests in one time step using an operation $\mathbf{nondelta}$ which prevents the transition of time in any non idle state. This removes the possibility for train to take an arbitrary amount of time to respond to a request, significantly cutting down on the state space.













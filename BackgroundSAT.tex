\chapter{Background: Resolution and the Satisfiability Problem}
In the following we shall present the satisfiability problem and  algorithms which solve this problem which are commonly known as SAT solvers. We are particularly interested in the Davis Putman Logemann Loveland algorithm \cite{DPLL} which is an improvement of the first SAT solving algorithm by Davis and Putnam \cite{MD60}. This solvers are geared towards solving formulas that are structured in CNF Moving on from these early SAT algorithms, we shall introduce some more recent SAT algorithms that are improvements on the original DPLL algorithm and include optimisations such as \emph{clause learning} and \emph{non-chronological back tracking}. Finally, we look at the resolution algorithm \cite{JR65}, which was directly inspired by the DPLL algorithm, and its associated proof system. The connection between these algorithms is so fundemental infact that the DPLL proof system is equivalent to a restricted form of resolution namely \emph{tree resolution} \cite{} and clause learning algorithms have been shown to implement \emph{general resolution} \cite{}. A general introduction to the satisfiability problem and SAT solvers can be found in The Handbook of Satisfiability \cite{}.


\section{The Satisfiability Problem}
In the following section we will introduce some preliminaries followed by the boolean satisfaction problem, which is the problem of finding a set of assignments to the variables of a formula such that the formula itself becomes true. The majority of modern algorithms for solving this problem work on propositional formulas in \emph{conjunctive normal form}. That is the formula is a conjunction of clauses which are themselves disjunctions of literals. This encoding has the advantage that had a very simple and structured form making algorithm implementation easier.
\medskip
\begin{mydef}[Preliminaries]
We define the following preliminaries to use when refering to DPLL SAT algorithms:

\begin{enumerate}
\item A \emph{literal} $l$ is either a positive variable $+v$ or a negative variable $-v$, i.e.\ a variable $v$ with a label $+$ or ${-}$ attached.

\item For every literal $l$ we define the opposite literal $\mybar{l}$ by $\mybar{+v}= -v$, $\mybar{-v} = +v$. 

\item We set $\var(+v) = \var(-v) = v$, $\var(L) = \{\var(l) \mid l\in L\}$
for a set of literals $L$, and 
$\var(\Delta) = \bigcup\{\var(L)\mid L\in\Delta\}$ for a set of sets of 
literals $\Delta$.

\item A \emph{clause} $C$ is a finite set of literals 
$\{ l_1, \ldots , l_k \}$, to be viewed as the disjunction of the literals.

\item A formula in \emph{conjunctive normal form} (CNF) is a 
finite conjunction of clauses. 
%where a clause is a finite disjunction of propositional literals giving it the structure: 
%%
%$$\bigwedge^n_{i=1}(l_1 \vee l_2 \vee \ldots \vee l_{k_i})$$.
%
By a \emph{formula} $\Delta$ we will always mean a formula in CNF,
and we will identify it with a finite set of clauses 
$\{ C_1 , \ldots , C_k \}$, representing the conjunction of the $C_i$.

\item A \emph{valuation} $\Gamma$ is a finite set of literals $\{ l_1, \ldots , l_k \}$ to be viewed as the conjunction of the elements.

\item A valuation $\Gamma$ is \emph{consistent} ($\consistent{\Gamma}$) if 
%
$\forall l \,( l \in \Gamma \to \mybar{l} \notin \Gamma)$.
We let $\consvals$ denote the set of all consistent valuations.


\item A \emph{model} is a total function $M$ which maps literals to booleans and satisfies the property
%
$\forall l \, (M \ l \leftrightarrow \neg M \ \mybar{l})$.
%
\end{enumerate}
%
We shall use the abbreviations 
%
\begin{itemize}
%
\item $M \models \Gamma$, for $\forall l \in \Gamma \, (M \ l)$ 
(`$M$ is a model of $\Gamma$'),
%
\item $M \models \Delta$, for 
$\forall C \in \Delta \, \exists l \in C \,(M \ l)$ 
(`$M$ is a model of $\Delta$').
%
\end{itemize}
%
We call a valuation $\Gamma$ and a formula $\Delta$ \emph{compatible} 
($\compatible{\Gamma}{\Delta})$
if there exists a model satisfying both, i.e. 
$\exists M \, (M \models \Gamma \wedge M\models \Delta)$;
otherwise $\Gamma$ and $\Delta$ are called \emph{incompatible} 
($\incompatible{\Gamma}{\Delta}$).

Note: we will modify some of these definitions in order to make algorithmic improvements.
\end{mydef}

%
%\begin{definition}
A \emph{sequent} $\Gamma \vdash \Delta$ is a pair consisting of a valuation and a formula.
%\end{definition}
%
The intended meaning of a sequent $\Gamma \vdash \Delta$ is that $\Gamma$ and $\Delta$
are incompatible. As a special case, when $\Gamma$ is empty, $\vdash \Delta$ means that $\Delta$ is unsatisfiable. 
\begin{comment}
\begin{defi}
We define an equivalence relation $\sim$ over the formulae $\Delta_1$ and $\Delta_2$ as follows
$$\Delta_1 \sim \Delta_2 \leftrightarrow \forall C .( C \in \Delta_1 \leftrightarrow C \in \Delta_2) $$
\end{defi}
\end{comment}
%
In the following we use the notations $X,a := \{x \mid x\in X \lor x = a\}$ 
(adding $a$ to the set $X$) and 
$X\setminus a := \{x \mid x\in X \land x \neq a\}$ (removing $a$ from $X$).
%
\medskip
\begin{mydef}[The boolean satisfiability (SAT) problem]
Given a formula $\Delta$, does there exist a valuation $\Gamma$ such that:
$$\Gamma \models \Delta$$
\end{mydef}
This is an NP complete problem, meaning that it is solveable by a non-deterministic turing machine in polynomial time. Such problem are solved by a back tracking search for a potential solution, first an  assignment the variables is tried, if that fails then the algorithm un does some assignments and tries another solution until all potential solutions have been tried. If all potential solutions do not satisfy the problem then it is said to be unsatisfiable i.e. it has no solution.
\section{The DPLL Algorithm}
The DPLL algorithm attempts to solve the satisfiability problem by performing a search of problem space. The algorithm consists of a split operation which causes a branching over a literal the resulting problems in the two sub trees are then simplified using a set of rules before a further branching is applied.
\bigskip
\begin{figure}[h!]
\begin{center}
\begin{tikzpicture}
\tikzstyle{arrow}=[->, thick]
\draw[arrow] (0,0) -- node [above = 10pt, left = 1pt] {$+x_1$} (-1,-1);

\end{tikzpicture}
\end{center}
\caption{The branching search of the DPLL algorithme}
\end{figure}
\bigskip

Add a more detailed explaination of the algorithm.


\begin{lstlisting}[caption = Example DPLL Algorithm,mathescape]
DPLL($\Delta$)
($\Gamma$,$\Delta'$) = Unit-Resolution($\Delta$)
if $\Delta$ = {} then
	return $\Gamma$
else if {} $\in \Delta$ then
	return UNSAT
else
	select a literal $l$ from $\Delta$
	if $\Gamma'$ = DPLL($\Delta' \cup \{l\}$) $\neq$ UNSAT then
		return $\Gamma' \cup \Gamma$ 
	else if $\Gamma'$ = DPLL($\Delta' \cup \{\neg l\}$) $\neq$ UNSAT then 
		return $\Gamma' \cup \Gamma$ 
	else
		return UNSAT
\end{lstlisting}



\subsection*{DPLL Proof System}

The  search that this algorithm performs can be viewed as constructing a proof of unsatisfiability for a given formula. The individual operations carried out to during the search correspond to rules in a proof system. The Unit-Resolution step can be broken down into 3 operations, one that adds unit clauses to the valuation, another that removes clauses that have been satisfied by a literal set to true and finally we have a rule that rules a literal from a clause if its opposing literal is in the valuation. There is an axiom rule $\Conflict$ corresponding to the cases in the algorithm where the empty clause has been derived. Finally, there is a branching rule refered to as $\Split$ which a deicison to be made on a literal with a branch in which that literal is true in the valuation and anothe branch in which it is false.
\medskip
\begin{mydef}[DPLL Proof System] The DPLL proof system consists 
of five rules: 
\label{def:proofsystem-DPLL}
\bigskip \\
%
\begin{center}
%
\AxiomC{$\Gamma, l \vdash \Delta $}
\RightLabel{($\Unit$)}
\UnaryInfC{$\Gamma \vdash \Delta, \{l \} $}
\DisplayProof \
%
\qquad
%
\AxiomC{$\Gamma, l  \vdash \Delta, C$}
\RightLabel{($\Red$)}
\UnaryInfC{$\Gamma, l \vdash \Delta, (C,\mybar{l})$}
\DisplayProof \
%
\qquad
%
\AxiomC{$\Gamma, l \vdash \Delta$}
\RightLabel{($\Elim$)}
\UnaryInfC{$\Gamma, l \vdash \Delta,(C,l)$}
\DisplayProof \

\bigskip

\AxiomC{$$}
\RightLabel{($\Conflict$)}
\UnaryInfC{$\Gamma \vdash \Delta,  \emptyset$}
\DisplayProof \
%
\qquad
%
\AxiomC{$\Gamma,l \vdash \Delta$}
\AxiomC{$\Gamma, \mybar{l} \vdash \Delta$}
\RightLabel{($\Split$)}
\BinaryInfC{$\Gamma  \vdash \Delta$}
\DisplayProof \
%
\end{center}
%
\end{mydef}
\section{CDCL Algorithms}
Similarily to the DPLL algorithms, conflict driven clause learning algorithms take as input a formula $\Delta$ in Conjunctive Normal Form. 
A valuation in a clause learning algorithm is typically a total function $\Gamma : \var{\Delta} \to \{0,1,u\}$ that maps to boolean variables of the formula $\Delta$ to a value $0,1$ or $u$ the unassigned value. The depth at which a boolean variable $x$ is assigned a value \{0,1 \} in the search tree is called the decision level which is represented as a function $\delta(x) \in \{-1,0,1, \ldots, |\var{\Delta}| \} $. Instead of removing literals from clauses when they are set to $0$ or removing a clause from the formula when it contains a literal set to $1$ all clauses and their corresponding literals remain in the clause during the search.


GRASP \cite{MS99,MS96}
Chaff ZChaff \cite{LZ01}
MiniSAT


\begin{lstlisting}[caption = Example CDCL Algorithm, mathescape]
CDCL($\Delta$,$\Gamma$)
$(\Delta,\Gamma) = \mathrm{Unit-Resolution}(\Delta,\Gamma)$
if $\{ \} \in \Delta$
	then return UNSAT
$dl \leftarrow 0$
while($\neg \mathrm{ALLVARIABLESASSIGNED}(\Delta,\Gamma$)) do
	do (x,v) = select(\Delta,\Gamma)
 	     $dl \leftarrow dl + 1$
 	     $\Gamma \leftarrow  \Gamma \cup \{ (x,v)\}$
	     $(\Delta,\Gamma) = \mathrm{Unit-Resolution}(\Delta,\Gamma)$

\end{lstlisting}


Example Clause Learning Algorithm

\section{Resolution}

Resolution Proof System


\begin{mydef}[Resolution Proof System] The derivable resolution sequents $\Gamma \modres{n} C$ with a derivation of size $n$ are conveniently defined by two rules: Subsumption (or axiom) and resolution.
%
\bigskip

\label{def:resolutionps}
\begin{center}
\AxiomC{\phantom{$\Delta \modres{n} C \vee l$}}
\RightLabel{($\Sub$)  $C \subseteq C'$ }
\UnaryInfC{$\Delta,C \modres{0} C'$}
\DisplayProof
%
\qquad
%
\AxiomC{$\Delta \modres{n} C \vee l$}
\AxiomC{$ \Delta \modres{m} C' \vee \bar{l}$}
\RightLabel{($\Res$)}
\BinaryInfC{$\Delta \modres{n + m + 1} C \vee C'$}
\DisplayProof 
\end{center}
\bigskip
\end{mydef}

Resolution Algorithm

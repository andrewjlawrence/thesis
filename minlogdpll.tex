\thesischapter{Extracting Verified Decision Procedures in the Minlog System}{Extracting Verified Decision Procedures in the Minlog System} \label{chapter:dpllminlog}
In the following chapter we describe how the completeness proofs from chapter \ref{chapter:dpll} are implemented in the Minlog system and how Minlog can be used to extract programs from these proofs.  This begins with the definition of preliminary data types and operations described in chapter \ref{chapter:dpll} and is followed by the implementation of the soundness and completeness of the DPLL proof system in Minlog. A unique feature of the Minlog system, namely \emph{non-computational quantifiers}, have been used to remove redundant data and computations and obtain a more efficient extracted program. The performance and behaviour of the extracted program is analysed in chapter \ref{chapter:dpllapp}. A detailed overview of the Minlog system can be found in the Minlog Reference Manual \cite{MinlogRef}.

\section{Formalising Preliminaries in the Minlog System}
We have tried to stay faithful to the definition of the fundamental data types described in chapter \ref{chapter:satbackground} and to this end have defined a number of data types as algebras in Minlog, including the variable, literal, valuation, clause and formula. The variable is defined using the command $\mathbf{add-alg}$ which adds an algebra named "variable " with one constructor "Variable" which takes a natural number and returns a variable.
\begin{lstlisting}[caption = "Definition of a variable in Minlog"]
(add-alg "variable" '("Variable" "nat => variable"))
\end{lstlisting}
The literal is also defined as an algebra but has two constructors "Pos" and "Neg" which are used to construct positive and negative literals respectively from a variable.
\begin{lstlisting}[caption = "Definition of a literal in Minlog"]
(add-alg "lit" '("Pos" "variable => lit")
     '("Neg" "variable => lit"))
\end{lstlisting}

We have defined an operation $\mathbf{opposite}$ which computes the opposite polarity of a literal. This is defined using \emph{program constants} and \emph{computational rules} as follows:

\begin{lstlisting}[caption = "Definition of the opposite operation in the Minlog System"]
(add-program-constant "opposite" 
     (mk-arrow (py "lit") (py "lit")) 1)
(add-computation-rule (pt "opposite (Pos v)") (pt "Neg v"))
(add-computation-rule (pt "opposite (Neg v)") (pt "Pos v"))
\end{lstlisting}


Functions in Minlog are defined using program constants which have a type and then giving these constants computational meaning with the introduction of computational rules. The \texttt{add-program-constant} command takes as input the name, arity and totality of the program constant. The \texttt{mk-arrow} function returns the type computed by composing its arguments together with an arrow. The \texttt{add-computation-rule} command defines computation for a program constant by pattern matching on the first argument and transforming it into result of the second argument.


\subsection*{Sets: Clauses, Valuations and Formulae}
There is currently no built in data type for sets in the Minlog system. For our work we have implemented sets as lists in the Minlog system. While this is not the most mathematically pure way of implementing these data types it has enabled us to make further efficiency improvements. The clauses have been implemented in such a way that the literals contained within are partitioned into positive and negative literals and then ordered within each of these partitions by variable number. The positive literals occur first followed by the negative and the variables are sorted from low to high numbers. We do not place any partitioning or ordering on either the formulae or the valuations; they are built using unsorted lists.

\begin{lstlisting}[caption = "Definitions of clauses\, formulae and valuations in the Minlog system"]
(add-alg "cla"  '( "CC" "list lit => cla"))
(add-alg "for" '( "CF" "list cla => for"))
(add-alg "valu" '( "ConsVal" "list lit => valu") )
\end{lstlisting}

\subsection*{Variable Namings}
In Minlog one defines variable names to have a particular type.  These variable names can then be used during a formalisation either as they are or with a suffix consisting of a natural number e.g. if we define \texttt{l} to be a variable name for literals then we can use the variable name \texttt{l1} to represent a literal in our formalisation.

\begin{lstlisting}[caption = "Variable namings for the DPLL formalisation in Minlog"]
(add-var-name "v" (py "variable"))
(add-var-name "vs"(py "list variable"))
(add-var-name "l"  (py "lit"))
(add-var-name "ls" (py "list lit"))
(add-var-name "c"  (py "cla"))
(add-var-name "cs" (py "list cla"))
(add-var-name "f"  (py "for"))
(add-var-name "b" (py "boole"))
\end{lstlisting}

\subsection*{Set Operations}
Due to there being no built in library for sets we have defined several operations on sets in Minlog. The  undecidability of equality and some limitations of polymorphism in Minlog have caused us to implement specific operations for each data type. While this has made the verification task hard, it has also given us a firmer grip on the extracted program, allowing us to make such implementation decisions as the ordering of literals in the clause. One piece of future work which would be valuable to the Minlog community even if it is not scientifically valuable would be to come up with a implementation of sets that will allow for program extraction and contains proof tactics that make reasoning about these sets less time consuming. We shall now give a brief overview of some of the set operations we have implemented as part of this formalisation. The CNF formula has no predefined structure which makes the addition and removal of elements straightforward.

\begin{lstlisting}[caption = "Code for the addition and removal of clauses from formulae"]
(add-program-constant "conccf" (py "cla => for => for") 1)
(add-computation-rule (pt  "conccf c (CF cs)")
                      (pt  "(CF (c::cs)) "))
\end{lstlisting}

The function \texttt{conccf} is used to insert clauses into a formula; it has one computation rule which simply adds the clause to the list of clauses contained within the formula. Likewise, the insertion of literals into a valuation is achieved by adding the literal to the front of the list of literals contained within the clause.

\begin{lstlisting}[caption = "The Function for the addition of a literal to a valuation"]
(add-program-constant "conclv" (py "lit => valu => valu") 1)
(add-computation-rule (pt "conclv l (ConsVal ls)")
                      (pt "ConsVal (l::ls) "))
\end{lstlisting}


The insertion of literals into clauses is more complicated due to the structure we have decided to implement. Clauses are partitioned into positive and negative literals and then ordered by variable number.


\begin{lstlisting}[caption =  "Functions for the insertion of a literal into a clause"]
(add-program-constant "conclc" (py "lit => cla => cla") 1)
(add-computation-rule (pt "conclc l (CC ls)") 
  (pt "(CC (Conclitlitlist l ls))"))

(add-program-constant "Conclitlitlist" 
  (py "lit => list lit => list lit") 1)

(add-computation-rule (pt "Conclitlitlist l (Nil lit)") (pt "l:"))

(add-computation-rule (pt "Conclitlitlist (Pos v)  ((Pos v2)::ls)")
  (pt "([if (v =  v2)                                                                                                       
              ((Pos v2)::ls)                                                                                       
              ([if (Num v < Num v2 )                                                                               
                   ((Pos v)::(Pos v2)::ls)                                                                         
                   ((Pos v2)::( Conclitlitlist (Pos v)  ls)) ])])"))

(add-computation-rule (pt "Conclitlitlist (Pos v) ((Neg v2)::ls)")
  (pt " ((Pos v)::(Neg v2)::ls)"))

(add-computation-rule (pt "Conclitlitlist (Neg v) ((Pos v2)::ls)")
  (pt "(Pos v2)::(Conclitlitlist (Neg v)  ls)"))

(add-computation-rule (pt "Conclitlitlist (Neg v) ((Neg v2)::ls)")
  (pt "([if (v = v2)                                                                                                        
              ((Neg v2)::ls)                                                                                      
              ([if (Num v <  Num v2 )                                                                              
                   ((Neg v)::(Neg v2)::ls)                                                                        
                   ((Neg v2)::(Conclitlitlist (Neg v) ls))])])"))
\end{lstlisting}

While the function \texttt{conclc}  is most commonly used in the formalisation, the work of adding a literal to the clause is carried out internally by the function \texttt{Conclitlitlist}. The \texttt{\justify Conclitlitlist} function is defined by five computational rules that pattern match on both the literal to be added and the structure of the list to which the literal is to be added. In particular the first literal of the list is matched on if there is such a literal, otherwise there is a rule to deal with the empty list. The rules cause the function to recursively search through the list attempting to place the literal in the right partition and in the right place in the order. The function also checks that such a literal does not already exist in the list which makes the addition of such a literal to the list redundant.

\begin{lstlisting}[caption = "The Function Which Removes a Literal From a Clause"]
(add-program-constant "remlc" (py "lit => cla => cla") 1)
(add-computation-rule (pt "remlc l (CC (Nil lit))") 
                     (pt "CC(Nil lit) "))
(add-computation-rule (pt "remlc l (CC (l2::ls)) ")
                      (pt "([ if (l = l2)                                       
                              (CC ls)                                           
                              (conclc l2 (remlc l (CC ls)))])"))
\end{lstlisting}

The function \texttt{remlc} for removing literals from clauses performs a recursive search through the list of literals in the clause until it finds a matching literal or the empty list. In either case the function returns the remaining list.






\subsection*{Models}
We implement models as a variable of type $literal \to boole$:
\begin{center}
\texttt{(add-var-name "mod" (mk-arrow (py "lit") (py "boole")))}
\end{center}
The behaviour of models is captured axiomatically by the addition of a global assumption in the Minlog system:
\begin{center}
\texttt{(aga "modelproperty" (pf "all mod, l . ( mod l  -> (mod (opposite l) -> F)) \& ( (mod (opposite l) -> F) -> mod l)"))}
\end{center}
We have implemented a model as a mapping from literals to booleans as during the proof search we construct a valuation which is a set of literals. In the case that a satisfying assignment is found we extend this set of literals to be a function. This is done using the following minlog code:

\begin{lstlisting}[caption = "The ExtendVal function in Minlog"]
(add-program-constant "ExtendVal" (py "valu => lit => boole") 
       t-deg-one 'const 1)
(add-computation-rule  (pt "ExtendVal val")  
                                (pt "lambda l2 [if (memlv l2 val)                                                                                                       
                                                          (T)                                                                                                                        
                                                          (F)]") )
\end{lstlisting}



\subsection*{The DPLL Proof System}
The DPLL proof system has been formalised as an inductive definition in the Minlog system with five closure axioms corresponding to the five proof rules. The inductive definition is represented internally as an algebra with the names of the closure axioms being used as constructors.

\begin{lstlisting}[caption = "The DPLL Proof System as an Inductive Definition in Minlog"]
(add-ids (list 
     (list "dpll" (make-arity (py "valu") (py "for")) "algdpll" ))
     '("allnc val, f. (memcf (CC (Nil lit)) f -> dpll val f)"
      "Conflict")

     '("allnc val, f. all c, l. (memlv l val ->                                                                                                             
         memlc l c ->                                                                                                                     
         memcf c f ->                                                                                                                     
         dpll  val (remcf c f) ->                                                                                                         
         dpll  val f ) "
        "Elim")

     '("allnc  val, f. all l. (memcf (CC (l:)) f ->                                                                                                         
        dpll  (conclv l val) (remcf (CC (l:)) f) ->                                                                                        
        dpll val f)"
        "Unit")

     '( "allnc val,f. all c,l. ( memlv l val ->                                                                                                             
         memlc (opposite l) c ->                                                                                                         
         memcf c f ->                                                                                                                    
         dpll val (conccf (remlc (opposite l) c) (remcf c f)) ->                                                                         
         dpll val f)"
      "Red")

     '( "allnc val, f. all l. (                                                                                                                             
         dpll (conclv l val) f ->                                                                                                         
         dpll (conclv (opposite l) val) f ->                                                                                              
         dpll  val f )"
      "Split")
)
\end{lstlisting}

This inductive definition contains a number of \texttt{allnc} quantifiers which will remove redundant data from the data structure which is extracted from this inductive definition. The valuation \texttt{val} and formula \texttt{f} have this non-computational label in each of the closure axioms. If the valuation and formula were not labelled as non-computational then a copy of them would exist in every node of the proof tree which would make the extracted program extremely inefficient in terms of memory consumption. The only information that is needed in the derivation of unsatisfiability is how the empty clause is reached in each branch of the proof.


\section{The Soundness (Incompatibility) of the DPLL Proof System in Minlog}
We have formalised the incompatibility proof for the DPLL proof system following the proof found in chapter \ref{chapter:DPLL} that proof and this formalisation are both based on the Coq implementation \cite{SL08}. We shall now sketch some of the steps to carry out the proof using the Minlog system.
The proof goal is set in the Minlog system using the \texttt{set-goal} command:

\begin{lstlisting}
(set-goal (pf 
   " all val,f.
       dpll val f ->  
       (all mod.( all l  (memlv l val -> mod l) ) -> 
       (all c . memcf c f ->( ex l.  memlc l c & mod l )) ->  F)"))
\end{lstlisting}

Here the function \texttt{pf} parses the formula to be proven into the Minlog system. The \texttt{assume} command is applied to fix the valuation \texttt{val} and the formula \texttt{f} and the \texttt{elim} command is applied to perform structural induction on the build up of the DPLL derivation \texttt{dpll val f} resulting in the five cases as described in the written description of the proof. Each of these cases requires that a further valuation \texttt{val1} and formula \texttt{f1} are fixed before proceeding.

\begin{lstlisting}[caption = "The Conflict Case in Minlog"]
?_3:allnc val,f(
  memcf(CC(Nil lit))f ->
  all mod(
   all l(memlv l val -> mod l) ->
   all c(memcf c f -> ex l(memlc l c & mod l)) -> F))
\end{lstlisting}

The proof for the $\Conflict$ case is performed using the assumption that the empty clause is in the formula \texttt{memcf(CC(Nil lit)) f1} and the assumption that every clause has a literal which is true in the model -- \texttt{all c(memcf c f1 -> ex l(memlc l c \& mod l))} -- to show a contradiction. 


\begin{lstlisting}[caption = "The Elim Case in Minlog"]
?_4:allnc val,f
  all c,l(
   memlv l val ->
   memlc l c ->
   memcf c f ->
   dpll val(remcf c f) ->
   all mod(
    all l0(memlv l0 val -> mod l0) ->
    all c0(memcf c0(remcf c f) -> ex l0(memlc l0 c0 & mod l0)) 
            -> F) ->
   all mod(
    all l0(memlv l0 val -> mod l0) ->
    all c0(memcf c0 f -> ex l0(memlc l0 c0 & mod l0)) -> F))
\end{lstlisting}
In addition to fixing a valuation and a formula using the \texttt{assume} command, in the Elim case we also use the \texttt{assume} command to fix a clause \texttt{c} and a literal \texttt{l} and make several assumptions. We assume that a literal l is in both \texttt{c} and the valuation \texttt{val1}, that the clause \texttt{c} is in the formula \texttt{f1}, that f1 with the clause \texttt{c} removed is incompatible with the valuation \texttt{val1} and finally that \texttt{f1} and \texttt{val1} are compatible. At this point the goal in Minlog is to show \texttt{F}. We apply the assumption that \texttt{remcf c f1} and the valuation \texttt{val1} are incompatible using the \texttt{use} command resulting in a new goal to show that \texttt{remcf c f1} and \texttt{val1} are compatible. We then apply a lemma \texttt{foralllemma} using the \texttt{use-with} command that states that in order to prove compatibility for a formula and a valuation it suffices to show compatibility for any larger formula, in which the smaller formula is contained, with that valuation.

\begin{center}
\textbf{foralllemma} := \texttt{all f,mod . all c( memcf c f -> ex l(memlc l c \& mod l)) -> all c,c1 (memcf c (remcf c1 f) -> ex l (memlc l c \&  mod l ))} \\
\end{center}

The resulting goal can then be proven using the \texttt{use} command with the assumption that the formula \texttt{f1} and the valuation {val1} are compatible.


\begin{lstlisting}[caption = "The Unit Case in Minlog"]
?_5:allnc val,f
     all l(
      memcf(CC l:)f ->
      dpll(conclv l val)(remcf(CC l:)f) ->
      all mod(
       all l0(memlv l0(conclv l val) -> mod l0) ->
       all c(memcf c(remcf(CC l:)f) -> ex l0(memlc l0 c & mod l0)) 
             -> F) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F))
\end{lstlisting}

In the Unit case a literal \texttt{l} is fixed in addition to \texttt{val1} and \texttt{f1} and several assumptions are made using the \texttt{assume} command.  We assume that there is a unit clause containing a single literal \texttt{l}, which is itself contained within the formula \text{f1}. We also assume that the valuation \texttt{conclv l val1} and the formula \texttt{remcf (CC l:) f1} are incompatible and that \texttt{f1} and \texttt{val1} are compatible under a fixed model \texttt{mod}. At this stage, the current goal to be proven is \texttt{F} to which we apply the assumption that \texttt{val1} and \texttt{remcf (CC l:) f1} are incompatible using the \texttt{use} command with \texttt{mod}, leaving us to prove that they are compatible under the model \texttt{mod}. The assumption  \texttt{all c(memcf c f1 -> ex l(memlc l c \& mod l))} is instantiated with \texttt{CC l:} using the \texttt{inst-with} command and then the \texttt{ex-elim} command is applied to eliminate the existential quantifier and obtain \texttt{memlc l0(CC l:) \& mod l0}. The \texttt{ng} (normalise goal) command normalises \texttt{memlc l0 (CC l:)} to \texttt{l0 = l} allowing us to use the following lemma to obtain \texttt{mod l}:

\begin{center}
\textbf{Model-m} := \texttt{all mod,l0,l1. l0 = l1 -> mod l0 -> mod l1} \\
\end{center}

The assumptions \texttt{mod l} and \texttt{all l (memlv l val -> mod l)}  are used with the following lemma to show part of the current goal \texttt{all l1. memlv l1 (conclv l val) -> mod l}:
\begin{center}
\textbf{SubModel-add} := \texttt{all mod, val,l1. all l (memlv l val  -> mod l) -> mod l1 -> all l. memlv l (conclv l1 val ) -> mod l"} \\
\end{center}

The remaining part of the goal to be shown is \texttt{\justify all c(memcf c(remcf(CC l:)f1) -> ex l0(memlc l0 c \& mod l0))}. The proof follows a similar approach to that used in the Elim case using the lemma \texttt{foralllemma}.

\begin{lstlisting}[caption = "The Reduce Case in Minlog"]
?_6:allnc val,f
     all c,l(
      memlv l val ->
      memlc(opposite l)c ->
      memcf c f ->
      dpll val(conccf(remlc(opposite l)c)(remcf c f)) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c0(
        memcf c0(conccf(remlc(opposite l)c)(remcf c f)) ->
        ex l0(memlc l0 c0 & mod l0)) 
        -> F) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c0(memcf c0 f -> ex l0(memlc l0 c0 & mod l0)) -> F))
\end{lstlisting}

The proof of the Reduce case begins by fixing a clause \texttt{c} and a literal \texttt{l} and making several assumptions using the \texttt{assume} command. We assume that the literal \texttt{l} is in \texttt{val1}, that \texttt{c} contains \texttt{opposite l}, that \texttt{c} is in \texttt{f}, that the formula \texttt{conccf(remlc(oppositel) c) (remcf c f1)} and \texttt{val1} are incompatible and that \texttt{f1} and \texttt{val1} are compatible under a fixed model \texttt{mod}. The assumption that \texttt{conccf(remlc(opposite l) c) (remcf c f1)} and \texttt{val1} are incompatible is applied, using the \texttt{(use 6 (pt "mod"))} command, to the current goal \texttt{F} leaving us to show that \texttt{conccf(remlc (opposite l) c) (remcf c f1)}  and \texttt{val1} are compatible under the model \texttt{mod}. We have as an assumption that the model \texttt{mod} models the valuation and this is applied to prove the first part of the compatibility goal. The second part involves us showing that \texttt{mod} models the formula \texttt{conccf(remlc (opposite l) c) (remcf c f1)} :
\begin{center}
\texttt{all c(
      memcf c(conccf(remlc(opposite l0)c0)(remcf c0 f0)) ->
      ex l(memlc l c \& mod l))}
\end{center}

To prove this we fix a clause \texttt{c1} using the \texttt{assume} command and then perform a case distinction using the command \texttt{(cases (pt "c1 = (remlc(opposite l0) c0)"))} (The (cases t) command results in two cases; one in which the term t holds and the other in which \texttt{t -> F} holds).  In the first case the \texttt{ex-intro} command is applied with \texttt{l1} leaving us to show \texttt{memlc l1 c1 \& mod l}. The \texttt{split} command allows us to prove each side of the conjunction in the current goal individually. To show \texttt{memlc l1 c1} we first use the \texttt{simp} command with the assumption \texttt{c1 = remlc (opposite l0) c0} to simplify the goal. The following lemma is then applied:
\begin{center}
\texttt{all l0,l1,c.  (l0 = l1 -> F) -> memlc l1 c -> memlc l1 (remlc l0 c)}
\end{center}

To show \texttt{opposite l0=l1 -> F} we assume \texttt{opposite l0 = l1} and then apply the model property leaving us to show \texttt{mod l0} and \texttt{mod (opposite l0)}. Using the assumptions that \texttt{l0} is in the valuation \texttt{val1} and that \texttt{mod} models the valuation \textbf{val1} we can obtain \texttt{mod l0}. We show \texttt{mod (opposite l0)} by simplifying the goal with \texttt{opposite l0 = l1} and then apply the assumption that \texttt{mod l1} holds using the \texttt{use} command.  In the case that \texttt{c1 = (remlc(opposite l0) c0) -> F} holds we apply the assumption that \texttt{mod} models \texttt{f1}, leaving the current goal as \texttt{memcf c1 f0}, and use the following lemma:

\begin{center}
\textbf{remove-lemma} := \texttt{all f1,c0,c1,l0. (c1=remlc(opposite l0) c0 -> F) -> memcf c1 (conccf(remlc(opposite l0) c0) (remcf c0 f1)) -> memcf c1 f1}  
\end{center}

\begin{lstlisting}[caption = "The Split Case in Minlog"]
?_7:allnc val,f
     all l(
      dpll(conclv l val)f ->
      all mod(
       all l0(memlv l0(conclv l val) -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F) ->
      dpll(conclv(opposite l)val)f ->
      all mod(
       all l0(memlv l0(conclv(opposite l)val) -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F))
\end{lstlisting}

The proof of the Split case proceeds by fixing a literal \texttt{l} and a model \texttt{mod} and making several assumptions using the \texttt{assume} command. We assume that \texttt{f1} and the valuations \texttt{conclv l val1} and \texttt{conclv (opposite l) val1} are incompatible and that \texttt{f1} and \texttt{val1} are compatible under the model \texttt{mod}. We then perform a case distinction on whether \texttt{mod l}  or \texttt{mod (opposite l)} using the \texttt{cases} command and the model property. In the case that \texttt{mod l} holds we apply the assumption that \texttt{conclv l val1} and \texttt{f1} are incompatible  to the goal \texttt{F}, using the use  command with \texttt{mod} as an arguement, resulting in a new goal that is to show that they are compatible under \texttt{mod}. \texttt{all l1. memlv l1 (conclv l val1) -> mod l1} is proven by fixing a literal \texttt{l1} using the assumptions \texttt{all l2. memlv l2 val1 -> mod l2} and \texttt{mod l} and by performing a case distinction on whether \texttt{l1 = l}. The case where \texttt{mod (opposite l)} holds is proven in a similar fashion using the assumption that \texttt{conclv (opposite l) val1} and \texttt{f1} are incompatible.




\section{The Completeness of the DPLL in Minlog}
The proof of completeness in Minlog follows the proof of completeness described in Chapter \ref{chapter:dpll}. There are however some implementation details such as the use of non-computational quantifiers and implementation of logical disjunction that are not dealt with in the paper proof and require some discussion. We begin by describing how the search heuristic for our SAT solver is inplemented and integrated at the proof level.



\subsection*{Selecting a Literal}
There are a wide range of established SAT heuristics that have been studied in great detail. We have however chosen to use the simplest heuristic available which selects the first literal. This is implemented using two program constants \texttt{Select} and \texttt{SelectLit} which pattern match on the first available clause to select the first available literal. In the case that the empty formula or an empty clause is searched for such a literal we return \texttt{(Pos (Variable 0))} which can be seen as a default variable as in either of those cases the search has terminated. 

\begin{lstlisting}[caption = The Literal Selection Function]
(add-program-constant "Select" (py "for => lit") 1)
(add-program-constant "SelectLit" (py "cla => lit") 1)

(add-computation-rule (pt "Select (CF (c::cs))") (pt "SelectLit c"))
(add-computation-rule (pt "Select (CF (Nil cla))")  
                         (pt "(Pos (Variable 0))")) 

(add-computation-rule (pt "SelectLit (CC (l::ls))") (pt "l"))
(add-computation-rule (pt "SelectLit (CC (Nil lit))") 
                         (pt "(Pos (Variable 0))"))
\end{lstlisting}

In order to integrate such a heuristic into our proof one has to prove the following statement. It states that for all non-empty lists of clauses such that all clauses are non empty, the function \texttt{Select} returns a literal \texttt{l} and that literal is in those clauses.

\begin{center}
\texttt{(set-goal (pf "allnc cs0.all c,cs ex l. cs0 = (c::cs) -> NoEmptycla(c::cs) -> Select (CF (c::cs)) = l \& memlitfor l (CF (c::cs))"))}
\end{center}


\subsection{Defining a Measure Function}
The measure function $\mu$ is defined in the Minlog system using a program constant \texttt{mu} and a computation rule.

(add-computation-rule (pt "mu cs1 cs2 val") (pt " Lh(toLit cs1) + Lh( toLit cs2) + Lh (varMinusVal cs1 cs2 val )"))

Where the \texttt{Lh} function computes the length of the list, the \texttt{toLit} function computes the set of literals contained within a clause list and \texttt{varMinusVal} computes the set minus of the set variables of the two lists of the clause and the set of variables contained within the valuation.

\subsection*{Defining Completeness}

We use an inductively defined predicate, called \texttt{success}, to capture the disjunction in the proof of completeness statement. The existential quantifier used in the model case has been replaced with a selection function \texttt{g} and a program constant \texttt{clausesat} which is defined axiomatically:

\begin{lstlisting}
(add-program-constant "clausesat" 
   (py "(lit => boole) => cla => lit => boole"))
(aga "clausesatprop1" 
   (pf "all mod,c,l. memlc l c & mod l -> clausesat mod c l"))
(aga "clausesatprop2" 
   (pf "all mod,c,l.  clausesat mod c l -> (memlc l c & mod l)"))

(add-program-constant "g" (py "(lit => boole)  => cla => lit") 1)
(add-computation-rule (pt "g mod (CC (l::ls))") 
   (pt "[if (mod l)                                                                                       
            l                                                                                     
            (g mod (CC ls))]"))
(add-computation-rule (pt "g mod (CC (Nil lit)) ") 
   (pt "(Pos (Variable  0))"))
\end{lstlisting}

The inductive definition of \texttt{success} contains two closure axioms corresponding to the cases that we either have a DPLL derivation of unsatisfiability or we have a model of the formula. 

\begin{lstlisting}[caption = "Inductive Definition of Completeness"]
(add-ids (list 
 (list "success" 
   (make-arity (py "list cla") (py "list cla") (py "valu"))
   "algsuccess" ))
 '("allnc cs1,cs2. allnc val.                                                                                                                
    dpll val (CF (cs1 ++ cs2)) ->                                                                                        
    success cs1 cs2 val "  )
'("allnc  cs1,cs2, val. all mod. all l( memlv l val -> mod l) ->                                                                      
   all c ( memcf c (CF (cs1 ++ cs2)) ->  
   ( clausesat mod c (g mod c) )) ->                                
   success cs1 cs2 val  " )
)
\end{lstlisting}



\subsection*{Proving Completeness}
The proof of completeness, from which we extract a verified SAT solver, is carried out by proving the following statement:

\begin{center}
\texttt{(set-goal (pf "all cs1. success cs1 (Nil cla) (ConsVal (Nil lit))"))}
\end{center}

In the above statement the list of clauses \texttt{cs1} has either a DPLL derivation or a model. Since the empty valuation is consistent and the second clause list is empty and cannot contain the empty clause the following theorem can be applied:


\begin{lstlisting}[caption = "Beginning of the Completeness Proof"]
(set-goal (pf "all cs1, cs2, val.  
 consistent val & 
 varIntersection (varv val) (varSetClaList cs2) = (Nil variable) -> 
 NoEmptycla cs2 ->  
 success cs1 cs2 val "))
(use "gRec")
(ind)
(use "base")
(use "step")
(save "DPLLSuccess")
\end{lstlisting}

The theorem \texttt{DPLLSucces} is partitioned into several sub theorems or lemmas which give the extracted program a more procedural structure. The theorem \texttt{gRec} contains the application of the guarded recursion.  The \texttt{base} theorem deals with the two cases in which \texttt{cs1} is empty, namely the \texttt{Model} and $\Split$ cases. The \texttt{step} theorem deals with all of the remaining cases in which the clause list \texttt{cs1} is non-empty, namely the \texttt{Conflict}, \texttt{Elim}, \texttt{Reduce} and \texttt{Unit} cases.


\section{The Modified DPLL and  Resolution Proof Systems in Minlog}
The DPLL and Resolution proof systems were modified in order to obtain a proof complexity result during the proof of equivalence between the two systems. A natural numbered counter has been added to the inductive definition of resolution enabling us to measure the size of the proofs. This enables us to perform a comparison between the size of resolution proofs and DPLL proofs.


\begin{lstlisting}
(add-ids (list (list "resolution" 
 (make-arity (py "for" ) (py "cla") (py "nat")) "algresolution"))
 '("all f,c2. all c1.  subseteq c1 c2 -> memcf c1 f -> 
    resolution f c2 (sizec c1) " "Sub")
 '("all f,c1,c2. all l,n,m.  resolution f (inslc l c1) n -> 
    resolution f (inslc (opposite l) c2) m -> 
    resolution f (ConcClause c1 c2) (n + m + 1)" "Res")
)
\end{lstlisting}

\section{The Completeness of the Resolution Proof System in Minlog}
The proof of completeness of the resolution proof system is performed by proving equivalence between the resolution and DPLL proof systems as described in \ref{chapter:dpll}.  
\begin{comment}
\begin{center}
\texttt{(set-goal  (pf "all f,c. all c0,n. resolution f c n  -> (memcf c0 f -> F) -> resolution (conccf c0 f) c n "))}
\end{center}

\begin{center}
\texttt{(set-goal (pf "all f,c. all c0,l0,n.  resolution f c n -> memcf c0 f -> ex m. m <= n +1 \& resolution (conccf(inslc  l0 c0)   (remcf c0 f)) (inslc l0 c) m "))}
\end{center}
\end{comment}

The following theorems have been proven in Minlog in order to show equivalence between the DPLL and resolution proof systems. 
\begin{center}
\texttt{(set-goal (pf "all f,c,n. resolution f c n -> all ls. c = (CC ls) -> ex m.  derivable (ConsVal (oppositeLiteral ls)) f m"))} \\
\texttt{(set-goal (pf "all f,val,n. derivable val f n -> ex m. m <= n \& resolution f (oppositeval val) m"))}
\end{center}

We inductively define a predicate \texttt{ressuccess} that captures what it means to have a successful run of a reslution algorithm. This is used in our proof of completeness 

\begin{lstlisting}
(add-ids (list 
 (list "ressuccess" (make-arity (py "for")) "algressuccess" ))
 '("allnc f.all n.                                                                                                                                           
    resolution f (CC (Nil lit)) n  ->                                                                                                    
    ressuccess f "  )
 '("allnc  f. all mod.                                                                                                                                 
    all c ( memcf c f ->  ( clausesat mod c (g mod c) )) ->                                                                
    ressuccess f  " )
)
\end{lstlisting}


The proof of completeness from which we extract a resolution solver proceeds as follows:

\begin{lstlisting}[caption = "Beginning of the Resolution Completeness Proof"]
(set-goal (pf "all f. WellFormedF f ->  ressuccess f "))
(assume "f")
(cases (pt "f"))
(assume "cs" "csprop" "wellformedprop")
(inst-with "DPLLSuccess" (pt "cs") 
 (pt "(Nil cla)") (pt "(ConsVal (Nil lit))"))
\end{lstlisting}

The instantiation of the DPLL completeness theorem with formula \texttt{f} is at the core of the proof. Following that a case distinction is made on whether the formula \texttt{f} has a DPLL derivation or a model. In the case that it has a DPLL derivation the equivalence theorem is applied to obtain a resolution derivation. In the case that the formula has a model, that model satisfies the second closure axiom of \texttt{ressucess}. 

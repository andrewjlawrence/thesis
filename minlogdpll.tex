\thesischapter{Extracting Verified Decision Procedures in the Minlog System}
In the following chapter we describe how the completeness proofs from chapter \ref{} are implemented in the Minlog system and how Minlog can be used to extract programs from these proofs.  This begins with the definition of preliminary data types and operations described in chapter \ref{ } and followed by the implementation of the completeness of the DPLL proof system in Minlog. The program extracted from the completeness is described along with a description of how a unique feature of the Minlog system, namely \emph{non-computational quantifiers} have been used to remove redundant data and computations and obtain a more efficient extracted program.


a formalisation of the DPLL proof system, as well as its soundness and completeness in the Minlog proof assistant.

\section{Formalising Preliminaries in the Minlog System}
We have tried to stay faithful to the definition of the fundemental data types described in chapter \ref{} and to this end have defined a number of data types as algebras in Minlog, including the variable,literal, valuation, clause and formula. The variable is defined using the command $\mathbf{add-alg}$ which adds an algebra named "variable " with one constructor "Variable" which takes a natural number and returns a variable.
\begin{lstlisting}[caption = "Definition of a variable in Minlog"]
(add-alg "variable" '("Variable" "nat => variable"))
\end{lstlisting}
The literal is also defined as an algebra but has two constructors "Pos" and "Neg" which are used to construct positive and negative literals respectively from a variable.
\begin{lstlisting}[caption = "Definition of a literal in Minlog"]
(add-alg "lit" '("Pos" "variable => lit")
     '("Neg" "variable => lit"))
\end{lstlisting}

We have defined an operation $\mathbf{opposite}$ which computes the opposite polarity of a literal. This is defined using

\begin{lstlisting}[caption = "Definition of the opposite operation in the Minlog System"]
(add-program-constant "opposite" 
     (mk-arrow (py "lit") (py "lit")) 1)
(add-computation-rule (pt "opposite (Pos v)") (pt "Neg v"))
(add-computation-rule (pt "opposite (Neg v)") (pt "Pos v"))
\end{lstlisting}

\subsection*{Sets: Clauses, Valuations and Formulae}
There is currently no built in data type for sets in the Minlog system. For our work we have implemented sets as lists in the Minlog system, while this is not the most mathematically pure way of implementing these data types it has enabled us to make further effciency improvements. The clauses have been implementated in such a way that the literals contained with in are partitioned into positive and negative literals and then ordered within each of these partitions by variable number. The positive literals occur first followed by the negative and the variables are sorted from low to high numbers. We do not place any partitionings or ordering on either the formulae or the valuations, they are built using unsorted lists.

\begin{lstlisting}[caption = "Definitions of clauses \, formulae and valulations in the Minlog system"]
(add-alg "cla"  '( "CC" "list lit => cla"))
(add-alg "for" '( "CF" "list cla => for"))
(add-alg "valu" '( "ConsVal" "list lit => valu") )
\end{lstlisting}

\subsection*{Set Operations}
Due to there being no built in library for sets we have defined several operations on sets in Minlog. The  undecidabilty of equality and some limitations of polymorphism in Minlog have caused us to implement specific operations for each data type. While this has made the verification task hard, it has also given us a firmer grip on the extracted programming, allowing us to make such implementation decisons as the ordering of literals in the clause. One piece of future work which would be valuable to the Minlog community even if it is not scientifically valuable would be to come up with a implementation of sets that will allow for program extraction and contains proof tactics that make reasoning about these sets less time consuming. We shall now give a brief overview of some of the set operations we have implemented as part of this formalisation.

\subsection*{The DPLL Proof System}
The DPLL proof/ system has been formalised as an inductive definition in the Minlog system with 5 closure axioms corresponding to the 5 proof rules. The inductive definition is represented internally as an algebra with the names of the closure axioms being used as constructors.

\begin{lstlisting}[caption = "The DPLL Proof System as an Inductive Definition in Minlog"]
(add-ids (list 
     (list "dpll" (make-arity (py "valu") (py "for")) "algdpll" ))
     '("allnc val, f. (memcf (CC (Nil lit)) f -> dpll val f)"
      "Conflict")

     '("allnc val, f. all c, l. (memlv l val ->                                                                                                             
         memlc l c ->                                                                                                                     
         memcf c f ->                                                                                                                     
         dpll  val (remcf c f) ->                                                                                                         
         dpll  val f ) "
        "Elim")

     '("allnc  val, f. all l. (memcf (CC (l:)) f ->                                                                                                         
        dpll  (conclv l val) (remcf (CC (l:)) f) ->                                                                                        
        dpll val f)"
        "Unit")

     '( "allnc val,f. all c,l. ( memlv l val ->                                                                                                             
         memlc (opposite l) c ->                                                                                                         
         memcf c f ->                                                                                                                    
         dpll val (conccf (remlc (opposite l) c) (remcf c f)) ->                                                                         
         dpll val f)"
      "Red")

     '( "allnc val, f. all l. (                                                                                                                             
         dpll (conclv l val) f ->                                                                                                         
         dpll (conclv (opposite l) val) f ->                                                                                              
         dpll  val f )"
      "Split")
)
\end{lstlisting}

This inductive definition contains a number of \texttt{allnc} quantifiers which will remove redundant data from the data structure which is extracted from this inductive definition. The valuation \texttt{val} and formula \texttt{f} have this non-computational label in each of the closure axioms. If the valuation and formula were not labelled as non-computational then a copy of them would exist in every node of the proof tree which would make the extracted program extremely inefficient in terms of memory consumption. The only information that is needed in the derivation of unsatisfiability is how the empty clause is reached in each branch of the proof.


\section{The Incompatibility of the DPLL Proof System in Minlog}
We have formalised the soundness proof for the DPLL proof system following the proof found in chapter \ref{chapter:DPLL}. We shall now sketch some of the steps to carry out the proof using the Minlog System.
The proof goal is set in the minlog system using the \texttt{set-goal} command:

\begin{lstlisting}
(set-goal (pf 
   " all val,f.
       dpll val f ->  
       (all mod.( all l  (memlv l val -> mod l) ) -> 
       (all c . memcf c f ->( ex l.  memlc l c & mod l )) ->  F)"))
\end{lstlisting}

Here the function \texttt{pf} parses the formula to be proven into the Minlog System. The \texttt{assume} command is applied to fix the valuation \texttt{val} and the formula \texttt{f} and the \texttt{elim} command is applied to perform structural induction on the build up of the DPLL derivation \texttt{dpll val f} resulting the 5 cases as described in the written description of the proof. Each of these cases require that a further valuation \texttt{val1} and formula \texttt{f1} are fixed before proceeding.

\begin{lstlisting}[caption = "The Conflict Case in Minlog"]
?_3:allnc val,f(
  memcf(CC(Nil lit))f ->
  all mod(
   all l(memlv l val -> mod l) ->
   all c(memcf c f -> ex l(memlc l c & mod l)) -> F))
\end{lstlisting}

The proof for this case is performed using the assumption that the empty clause is in the formula \texttt{memcf(CC(Nil lit)) f1} and the assumption that every clause has a literal which is true in the model \texttt{all c(memcf c f1 -> ex l(memlc l c \& mod l))} to show a contradiction. 


\begin{lstlisting}[caption = "The Elim Case in Minlog"]
?_4:allnc val,f
  all c,l(
   memlv l val ->
   memlc l c ->
   memcf c f ->
   dpll val(remcf c f) ->
   all mod(
    all l0(memlv l0 val -> mod l0) ->
    all c0(memcf c0(remcf c f) -> ex l0(memlc l0 c0 & mod l0)) -> F) ->
   all mod(
    all l0(memlv l0 val -> mod l0) ->
    all c0(memcf c0 f -> ex l0(memlc l0 c0 & mod l0)) -> F))
\end{lstlisting}
In addition to fixing a valuation and a formula using the \texttt{assume} command, in the Elim case we also use the command fix a clause \texttt{c} and a literal \texttt{l} and make several assumptions. We assume that a literal l is in both \texttt{c} and the valuation \texttt{val1}, that the clause \texttt{c} is in the formula \texttt{f1}, that f1 with the clause \texttt{c} removed is incompatible with the valuation \texttt{val1} and finally that \texttt{f1} and \texttt{val1} are compatible. At this point the goal in Minlog is to show \texttt{F}. We apply the assumption that \texttt{remcf c f1} and the valuation \texttt{val1} are incompatible using the \texttt{use} command resulting in a new goal to show that \texttt{remcf c f1} and \texttt{val1} are compatible. We then apply a lemma \texttt{foralllemma} using the \texttt{use-with} command that states that in order to prove compatibility for a formula and a valuation it suffices to show compatibility for any larger formula, of which the smaller formula is contained and that valuation.

\begin{center}
\texttt{all f,mod . all c( memcf c f -> ex l(memlc l c \& mod l)) -> all c,c1 (memcf c (remcf c1 f) -> ex l (memlc l c \&  mod l ))}
\end{center}

The resulting goal can then be proven using the \texttt{use} command with the assumption that the formula \texttt{f1} and the valuation {val1} are compatible.


\begin{lstlisting}[caption = "The Unit Case in Minlog"]
?_5:allnc val,f
     all l(
      memcf(CC l:)f ->
      dpll(conclv l val)(remcf(CC l:)f) ->
      all mod(
       all l0(memlv l0(conclv l val) -> mod l0) ->
       all c(memcf c(remcf(CC l:)f) -> ex l0(memlc l0 c & mod l0)) -> F) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F))
\end{lstlisting}

In the Unit case literal \texttt{l} is fixed in addition to \texttt{val1} and \texttt{f1} and several assumptions are made using the \texttt{assume} command.  


\begin{lstlisting}
?_6:allnc val,f
     all c,l(
      memlv l val ->
      memlc(opposite l)c ->
      memcf c f ->
      dpll val(conccf(remlc(opposite l)c)(remcf c f)) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c0(
        memcf c0(conccf(remlc(opposite l)c)(remcf c f)) ->
        ex l0(memlc l0 c0 & mod l0)) ->
       F) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c0(memcf c0 f -> ex l0(memlc l0 c0 & mod l0)) -> F))
\end{lstlisting}

\begin{lstlisting}
?_7:allnc val,f
     all l(
      dpll(conclv l val)f ->
      all mod(
       all l0(memlv l0(conclv l val) -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F) ->
      dpll(conclv(opposite l)val)f ->
      all mod(
       all l0(memlv l0(conclv(opposite l)val) -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F))
\end{lstlisting}
\section{The Completeness of the DPLL in Minlog}

\section{The Extracted DPLL Solver (XSAT)}

\section{The Resolution Proof System in Minlog}

\section{The Completeness of the Resolution Proof System in Minlog}
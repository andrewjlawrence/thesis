\thesischapter{Extracting Verified Decision Procedures in the Minlog System}{Extracting Verified Decision Procedures in the Minlog System} \label{chapter:dpllminlog}
In the following chapter we describe how the completeness proofs from chapter \ref{chapter:dpll} are implemented in the Minlog system and how Minlog can be used to extract programs from these proofs.  This begins with the definition of preliminary data types and operations described in chapter \ref{chapter:dpll} and followed by the implementation of the soundness and completeness of the DPLL proof system in Minlog. The program extracted from the completeness is described along with a description of how a unique feature of the Minlog system, namely \emph{non-computational quantifiers} have been used to remove redundant data and computations and obtain a more efficient extracted program. The performance and behaviour of the extracted program is analysed in chapter \ref{chapter:dpllapp}. A detailed overview of the Minlog system can be found in the Minlog Reference Manual \cite{}.

\section{Formalising Preliminaries in the Minlog System}
We have tried to stay faithful to the definition of the fundemental data types described in chapter \ref{} and to this end have defined a number of data types as algebras in Minlog, including the variable,literal, valuation, clause and formula. The variable is defined using the command $\mathbf{add-alg}$ which adds an algebra named "variable " with one constructor "Variable" which takes a natural number and returns a variable.
\begin{lstlisting}[caption = "Definition of a variable in Minlog"]
(add-alg "variable" '("Variable" "nat => variable"))
\end{lstlisting}
The literal is also defined as an algebra but has two constructors "Pos" and "Neg" which are used to construct positive and negative literals respectively from a variable.
\begin{lstlisting}[caption = "Definition of a literal in Minlog"]
(add-alg "lit" '("Pos" "variable => lit")
     '("Neg" "variable => lit"))
\end{lstlisting}

We have defined an operation $\mathbf{opposite}$ which computes the opposite polarity of a literal. This is defined using

\begin{lstlisting}[caption = "Definition of the opposite operation in the Minlog System"]
(add-program-constant "opposite" 
     (mk-arrow (py "lit") (py "lit")) 1)
(add-computation-rule (pt "opposite (Pos v)") (pt "Neg v"))
(add-computation-rule (pt "opposite (Neg v)") (pt "Pos v"))
\end{lstlisting}


Functions in Minlog are defined using program constants which have a type and then giving these constants computational meaning with the introduction of computational rules. The \texttt{add-program-constant} command takes as input the name, arity and totality of the program constant. The \texttt{mk-arrow} function returns the type computed by composing its arguments together with an arrow. The \texttt{add-computation-rule} command defines computation for a program constant by pattern matching on the 1st argument and transforming it into result of the second argument.


\subsection*{Sets: Clauses, Valuations and Formulae}
There is currently no built in data type for sets in the Minlog system. For our work we have implemented sets as lists in the Minlog system, while this is not the most mathematically pure way of implementing these data types it has enabled us to make further effciency improvements. The clauses have been implementated in such a way that the literals contained with in are partitioned into positive and negative literals and then ordered within each of these partitions by variable number. The positive literals occur first followed by the negative and the variables are sorted from low to high numbers. We do not place any partitionings or ordering on either the formulae or the valuations, they are built using unsorted lists.

\begin{lstlisting}[caption = "Definitions of clauses \, formulae and valulations in the Minlog system"]
(add-alg "cla"  '( "CC" "list lit => cla"))
(add-alg "for" '( "CF" "list cla => for"))
(add-alg "valu" '( "ConsVal" "list lit => valu") )
\end{lstlisting}

\subsection*{Models}
We implement models as a variable of type $literal \to boole$:
\begin{center}
\texttt{(add-var-name "mod" (mk-arrow (py "lit") (py "boole")))}
\end{center}
The behaviour of models is captured axiomatically by the addition of a global assumption in the Minlog system:
\begin{center}
\texttt{(aga "modelproperty" (pf "all mod, l . ( mod l  -> (mod (opposite l) -> F)) \& ( (mod (opposite l) -> F) -> mod l)"))}
\end{center}
We have implemented a model as a mapping from literals to booleans as during the proof search we construct a valuation which is a set of literals. In the case that a satisfying assignment is found we extend this set of literals to be a function. This is done using the following minlog code:

\begin{lstlisting}[caption = "The ExtendVal function in Minlog"]
(add-program-constant "ExtendVal" (py "valu => lit => boole") 
       t-deg-one 'const 1)
(add-computation-rule  (pt "ExtendVal val")  
                                (pt "lambda l2 [if (memlv l2 val)                                                                                                       
                                                          (T)                                                                                                                        
                                                          (F)]") )
\end{lstlisting}


\subsection*{Set Operations}
Due to there being no built in library for sets we have defined several operations on sets in Minlog. The  undecidabilty of equality and some limitations of polymorphism in Minlog have caused us to implement specific operations for each data type. While this has made the verification task hard, it has also given us a firmer grip on the extracted programming, allowing us to make such implementation decisons as the ordering of literals in the clause. One piece of future work which would be valuable to the Minlog community even if it is not scientifically valuable would be to come up with a implementation of sets that will allow for program extraction and contains proof tactics that make reasoning about these sets less time consuming. We shall now give a brief overview of some of the set operations we have implemented as part of this formalisation.



\subsection*{The DPLL Proof System}
The DPLL proof/ system has been formalised as an inductive definition in the Minlog system with 5 closure axioms corresponding to the 5 proof rules. The inductive definition is represented internally as an algebra with the names of the closure axioms being used as constructors.

\begin{lstlisting}[caption = "The DPLL Proof System as an Inductive Definition in Minlog"]
(add-ids (list 
     (list "dpll" (make-arity (py "valu") (py "for")) "algdpll" ))
     '("allnc val, f. (memcf (CC (Nil lit)) f -> dpll val f)"
      "Conflict")

     '("allnc val, f. all c, l. (memlv l val ->                                                                                                             
         memlc l c ->                                                                                                                     
         memcf c f ->                                                                                                                     
         dpll  val (remcf c f) ->                                                                                                         
         dpll  val f ) "
        "Elim")

     '("allnc  val, f. all l. (memcf (CC (l:)) f ->                                                                                                         
        dpll  (conclv l val) (remcf (CC (l:)) f) ->                                                                                        
        dpll val f)"
        "Unit")

     '( "allnc val,f. all c,l. ( memlv l val ->                                                                                                             
         memlc (opposite l) c ->                                                                                                         
         memcf c f ->                                                                                                                    
         dpll val (conccf (remlc (opposite l) c) (remcf c f)) ->                                                                         
         dpll val f)"
      "Red")

     '( "allnc val, f. all l. (                                                                                                                             
         dpll (conclv l val) f ->                                                                                                         
         dpll (conclv (opposite l) val) f ->                                                                                              
         dpll  val f )"
      "Split")
)
\end{lstlisting}

This inductive definition contains a number of \texttt{allnc} quantifiers which will remove redundant data from the data structure which is extracted from this inductive definition. The valuation \texttt{val} and formula \texttt{f} have this non-computational label in each of the closure axioms. If the valuation and formula were not labelled as non-computational then a copy of them would exist in every node of the proof tree which would make the extracted program extremely inefficient in terms of memory consumption. The only information that is needed in the derivation of unsatisfiability is how the empty clause is reached in each branch of the proof.


\section{The Soundness (Incompatibility) of the DPLL Proof System in Minlog}
We have formalised the incompatibility proof for the DPLL proof system following the proof found in chapter \ref{chapter:DPLL} that proof and this formalisation are both based on the Coq implementation \cite{}. We shall now sketch some of the steps to carry out the proof using the Minlog System.
The proof goal is set in the minlog system using the \texttt{set-goal} command:

\begin{lstlisting}
(set-goal (pf 
   " all val,f.
       dpll val f ->  
       (all mod.( all l  (memlv l val -> mod l) ) -> 
       (all c . memcf c f ->( ex l.  memlc l c & mod l )) ->  F)"))
\end{lstlisting}

Here the function \texttt{pf} parses the formula to be proven into the Minlog System. The \texttt{assume} command is applied to fix the valuation \texttt{val} and the formula \texttt{f} and the \texttt{elim} command is applied to perform structural induction on the build up of the DPLL derivation \texttt{dpll val f} resulting the 5 cases as described in the written description of the proof. Each of these cases require that a further valuation \texttt{val1} and formula \texttt{f1} are fixed before proceeding.

\begin{lstlisting}[caption = "The Conflict Case in Minlog"]
?_3:allnc val,f(
  memcf(CC(Nil lit))f ->
  all mod(
   all l(memlv l val -> mod l) ->
   all c(memcf c f -> ex l(memlc l c & mod l)) -> F))
\end{lstlisting}

The proof for this case is performed using the assumption that the empty clause is in the formula \texttt{memcf(CC(Nil lit)) f1} and the assumption that every clause has a literal which is true in the model \texttt{all c(memcf c f1 -> ex l(memlc l c \& mod l))} to show a contradiction. 


\begin{lstlisting}[caption = "The Elim Case in Minlog"]
?_4:allnc val,f
  all c,l(
   memlv l val ->
   memlc l c ->
   memcf c f ->
   dpll val(remcf c f) ->
   all mod(
    all l0(memlv l0 val -> mod l0) ->
    all c0(memcf c0(remcf c f) -> ex l0(memlc l0 c0 & mod l0)) 
            -> F) ->
   all mod(
    all l0(memlv l0 val -> mod l0) ->
    all c0(memcf c0 f -> ex l0(memlc l0 c0 & mod l0)) -> F))
\end{lstlisting}
In addition to fixing a valuation and a formula using the \texttt{assume} command, in the Elim case we also use the command fix a clause \texttt{c} and a literal \texttt{l} and make several assumptions. We assume that a literal l is in both \texttt{c} and the valuation \texttt{val1}, that the clause \texttt{c} is in the formula \texttt{f1}, that f1 with the clause \texttt{c} removed is incompatible with the valuation \texttt{val1} and finally that \texttt{f1} and \texttt{val1} are compatible. At this point the goal in Minlog is to show \texttt{F}. We apply the assumption that \texttt{remcf c f1} and the valuation \texttt{val1} are incompatible using the \texttt{use} command resulting in a new goal to show that \texttt{remcf c f1} and \texttt{val1} are compatible. We then apply a lemma \texttt{foralllemma} using the \texttt{use-with} command that states that in order to prove compatibility for a formula and a valuation it suffices to show compatibility for any larger formula, of which the smaller formula is contained and that valuation.

\begin{center}
\textbf{foralllemma} := \texttt{all f,mod . all c( memcf c f -> ex l(memlc l c \& mod l)) -> all c,c1 (memcf c (remcf c1 f) -> ex l (memlc l c \&  mod l ))} \\
\end{center}

The resulting goal can then be proven using the \texttt{use} command with the assumption that the formula \texttt{f1} and the valuation {val1} are compatible.


\begin{lstlisting}[caption = "The Unit Case in Minlog"]
?_5:allnc val,f
     all l(
      memcf(CC l:)f ->
      dpll(conclv l val)(remcf(CC l:)f) ->
      all mod(
       all l0(memlv l0(conclv l val) -> mod l0) ->
       all c(memcf c(remcf(CC l:)f) -> ex l0(memlc l0 c & mod l0)) 
             -> F) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F))
\end{lstlisting}

In the Unit case literal \texttt{l} is fixed in addition to \texttt{val1} and \texttt{f1} and several assumptions are made using the \texttt{assume} command.  We assume that there is a unit clause containing a single literal \texttt{l}, which is itself contained within the formula \text{f1}. We also assume that the valuation \texttt{conclv l val1} and the formula \texttt{remcf (CC l:) f1} are incompatible and that \texttt{f1} and \texttt{val1} are compatible under a fixed model \texttt{mod}. At this stage, the current goal to be proven is \texttt{F} to which we apply the assumption that \texttt{val1} and \texttt{remcf (CC l:) f1} are incompatible using the use command with \texttt{mod}, leaving us to prove that they are compatible under the model \texttt{mod}. The assumption  \texttt{all c(memcf c f1 -> ex l(memlc l c \& mod l))} instantiated with \texttt{CC l:} using the \texttt{inst-with} command and then the \texttt{ex-elim} command is applied to eliminated the existential quantifier and obtain \texttt{memlc l0(CC l:) \& mod l0}. The \texttt{ng} command normalises \texttt{memlc l0 (CC l:)} to \texttt{l0 = l} allowing us to use the following lemma to obtain \texttt{mod l}:

\begin{center}
\textbf{Model-m} := \texttt{all mod,l0,l1. l0 = l1 -> mod l0 -> mod l1} \\
\end{center}

The assumptions \texttt{mod l} and \texttt{all l (memlv l val -> mod l)}  are used with the following lemma to show part of the current goal \texttt{all l1. memlv l1 (conclv l val) -> mod l}:
\begin{center}
\textbf{SubModel-add} := \texttt{all mod, val,l1. all l (memlv l val  -> mod l) -> mod l1 -> all l. memlv l (conclv l1 val ) -> mod l"} \\
\end{center}

The remaining part of the goal to be show is \texttt{all c(memcf c(remcf(CC l:)f1) -> ex l0(memlc l0 c \& mod l0))} which follows a similar approach to that used in the Elim case using the lemma \texttt{foralllemma}.

\begin{lstlisting}[caption = "The Reduce Case in Minlog"]
?_6:allnc val,f
     all c,l(
      memlv l val ->
      memlc(opposite l)c ->
      memcf c f ->
      dpll val(conccf(remlc(opposite l)c)(remcf c f)) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c0(
        memcf c0(conccf(remlc(opposite l)c)(remcf c f)) ->
        ex l0(memlc l0 c0 & mod l0)) 
        -> F) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c0(memcf c0 f -> ex l0(memlc l0 c0 & mod l0)) -> F))
\end{lstlisting}

The proof of the Reduce case begins by fixing a clause \texttt{c} and a literal \texttt{l} and making several assumptions using the \texttt{assume} command. We assume that the literal \texttt{l} is in \texttt{val1}, that \texttt{c} contains \texttt{opposite l}, that \texttt{c} is in \texttt{f}, that the formula \texttt{conccf(remlc(oppositel) c) (remcf c f1)} and \texttt{val1} are incompatible and that \texttt{f1} and \texttt{val1} are compatible under a fixed model \texttt{mod}. The assumption that \texttt{conccf(remlc(opposite l) c) (remcf c f1)} and \texttt{val1} are incompatible is applied, using the \texttt{(use 6 (pt "mod"))} command, to the current goal \texttt{F} leaving us to show that \texttt{conccf(remlc (opposite l) c) (remcf c f1)}  and \texttt{val1} are compatible under the model \texttt{mod}. We have as an assumption that the model \texttt{mod} models the valuation and this is applied to prove the first part of the compatibility goal. The second part involves us showing that \texttt{mod} models the formula \texttt{conccf(remlc (opposite l) c) (remcf c f1)} :
\begin{center}
\texttt{all c(
      memcf c(conccf(remlc(opposite l0)c0)(remcf c0 f0)) ->
      ex l(memlc l c \& mod l))}
\end{center}

To prove this we fix a clause \texttt{c1} using the assume command and then perform a case distinction using command (cases (pt "c1 = (remlc(opposite l0) c0)")).  In the first case the \texttt{ex-intro} command is applied with \texttt{l1} leaving us to show \texttt{memlc l1 c1 \& mod l}. The \texttt{split} command allows us to prove each side conjunction in the current goal individually. To show \texttt{memlc l1 c1} we first use the \texttt{simp} command with the assumption \texttt{c1 = remlc (opposite l0) c0} to simplify the goal. The following lemma is then applied:
\begin{center}
\texttt{all l0,l1,c.  (l0 = l1 -> F) -> memlc l1 c -> memlc l1 (remlc l0 c)}
\end{center}

To show \texttt{opposite l0=l1 -> F} we assume \texttt{opposite l0 = l1} and then apply the model property leaving us to show \texttt{mod l0} and \texttt{mod (opposite l0)}. Using assumptions that \texttt{l0} is in the valuation \texttt{val1} and that \text{mod} models the valuation \textbf{val1} we can obtain \texttt{mod l0}. We show \texttt{mod (opposite l0)} by simplifying the goal with \texttt{opposite l0 = l1} and then apply the assumption that \texttt{mod l1} holds using the \texttt{use} command.  In the case that \texttt{c1 = (remlc(opposite l0) c0) -> F} holds we apply the assumption that \texttt{mod} models \texttt{f1}, leaving the current goal as \texttt{memcf c1 f0}, and use the following lemma:

\begin{center}
\textbf{remove-lemma} := \texttt{all f1,c0,c1,l0. (c1=remlc(opposite l0) c0 -> F) -> memcf c1 (conccf(remlc(opposite l0) c0) (remcf c0 f1)) -> memcf c1 f1}  
\end{center}

\begin{lstlisting}[caption = "The Split Case in Minlog"]
?_7:allnc val,f
     all l(
      dpll(conclv l val)f ->
      all mod(
       all l0(memlv l0(conclv l val) -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F) ->
      dpll(conclv(opposite l)val)f ->
      all mod(
       all l0(memlv l0(conclv(opposite l)val) -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F) ->
      all mod(
       all l0(memlv l0 val -> mod l0) ->
       all c(memcf c f -> ex l0(memlc l0 c & mod l0)) -> F))
\end{lstlisting}

The proof of the Split case proceeds by fixing a literal \texttt{l} and a model \texttt{mod} and making several assumptions using the \texttt{assume} command. We assume that \texttt{f1} and the valuations \texttt{conclv l val1} and \texttt{conclv (opposite l) val1} are incompatible and that \texttt{f1} and \texttt{val1} are compatible under the model \texttt{mod}. We then perform a case distinction on whether \texttt{mod l}  or \texttt{mod (opposite l)} using the \texttt{cases} command and the model property. In the case that \texttt{mod l} holds we apply the assume that \texttt{conclv l val1} and \texttt{f1} are incompatible  to the goal \texttt{F}, using the use  command with \texttt{mod} as an arguement, resulting in a new goal that is to show that they are compatible under \texttt{mod}. \texttt{all l1. memlv l1 (conclv l val1) -> mod l1} is proven by fixing a literal \texttt{l1} using the assumptions \texttt{all l2. memlv l2 val1 -> mod l2} and \texttt{mod l} and by performing a case distinction on whether \texttt{l1 = l}. The case the \texttt{mod (opposite l)} holds is proven in a similar fashion using the assumption that \texttt{conclv (opposite l) val1} and \texttt{f1} are incompatible.

\section{The Completeness of the DPLL in Minlog}
The proof of completeness in Minlog follows the proof of completeness described in Chapter \ref{chapter:dpll}. There are however some implementation details such as the use of non-computational quantifiers and implementation of logical disjunction that are not delt with in the paper proof and require some discussion.



\section{The Extracted DPLL Solver (XSAT)}

\section{The Resolution Proof System in Minlog}

\section{The Completeness of the Resolution Proof System in Minlog}
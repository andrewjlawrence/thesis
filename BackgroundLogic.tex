\mathchardef\mhyphen="2D
\newcommand{\mathass}[1]{\mathrm{[}#1 {]}}
\chapter{Background: Logic and Program Extraction}
We use logic to formally reason about the world around us in an abstract way. At the most basic level we are creating abstract propositions, sentences from these propositions and then using formal rules to deal with these propositions and to derive new information or insight. In the following we give a general introduction to logic and describe some of the formalisms used in this thesis.
A good general introduction to logic from a proof theoretic perspective is \cite{HandBookProof}.


\section{Propositional logic}
One of the most fundamental forms of logic is propositional logic which contains operations called connectives that allows one to connect propositional variables to form sentences.


\begin{mydef}[Propositional Formulae]
Given a set of propositional variables $V$ we inductively define the set of propositional formulae $AP$ as follows:
\begin{itemize}
\item If $s$ is in the set of symbols $s \in V$ then $s \in AP$.

\item if $p_1$ is a propositional formula $p_1 \in AP$ then $\neg p_1 \in AP$.

\item given two propositional formulae $p_1$ and $p_2$ then $p_1 \circ p_2 \in AP$ where $\circ$ is a propositional connective $\circ \in \{ \wedge,\vee,\to \} $.
\end{itemize} 
\end{mydef}
In order to define the semantics of propositional logic we need the notiona of a truth assignment which is a function $\tau : \{True,False\}^n \to \{True, False\}$ that gives a logical assignment to the set propositional variables $V$ which is of size $n$. This function can then be used to describe another function $\bar{\tau} : P \to \{True, False\}$ that given a propositional formula $P \in AP$ calculates a truth assignment for that formula based on $\tau$.

We assigned these sentences of propositions a value of either True or False using a truth assignment 
\begin{center}
\begin{tabular}{c | c | c | c | c | c | c} \hline
$A$ & $B$ & $\neg A$  & $A \wedge B$ & $A \vee B$ & $A \to B$ & $A \leftrightarrow B$  \\ \hline
 T & F & F  & T & T & T & T \\ \hline 
 T & T & F  & F & T & F & F \\ \hline
 F & F & T  & F & T & T & F \\ \hline
 F & T & T  & F & F & T & T \\ 
\end{tabular}
\end{center}

\section{First Order Logic}
\begin{mydef}[Syntax of First Order Logic]
Blah

\end{mydef}

\begin{mydef}[Semantics of First Order Logic]

\end{mydef}

\section{Linear Temporal Logic}
In order to perform model checking over a system we typically need a formal language that allows one to speak about time. We need to be able to formalise sentences such as "the next moment of time" and "all moments in time in the future". One such logic that allows us to formalise these statements is linear temporal logic (LTL)\cite{AP77}. 


Using these atomic propositions combined with the temporal operators it is possible to define a syntax for temporal logic formulae.

\begin{mydef}[Syntax of Linear Temporal Logic]
Let $AP$ be the set of propositional formulae then:

\begin{itemize}
\item $\top$ and $\bot$ are well formed formulas.
\item if $p \in AP$ then $p$ is well formed formula (wff).

\item if $f$ and $g$ are wff  then $\star f$ and $f \circ g$ are wffs where $\star \in \{\neg,\mathbf{X},\mathbf{G}, \mathbf{F}\}$ and $\circ \in \{ \wedge,\vee,\textbf{R},\textbf{U} \}$.
\end{itemize}

\end{mydef}
We write $LTL(AP)$ to denote the LTL logic formulas for a given set of atomic propositions $AP$.

LTL operations can be used to speak about paths through a system specified as a Kripke structure.
a \emph{path} $\pi$ is a sequence of states $s_1, \ldots s_n$ and a \emph{path formula} is one that holds in each given state of a path. We define $Path(K,s_0)$ to be the set of paths starting at state $s_0$ in the Kripke structure $K$ as the set of functions $\phi : N \to S$ such that $\phi(0) = a$ and the $\phi(n) \to \phi(n+1)$. 

We shall now look at the semantics of LTL firstly using an informal description of the LTL operations and secondly by giving a formal semantics for LTL. The following is a description of the 5 LTL operations over paths of a Kripke Structure.

\begin{itemize}
\item \textbf{X} $f$ : The property $f$ holds in the \emph{next} moment of time.
\item \textbf{G} $f$ : The property $f$ is \emph{globally} true. i.e. it holds for all times on all paths. 
\item \textbf{F} $f$ : The property $f$ is \emph{finally} true. i.e. there exists a time such that the property $f$ holds on a path.
\item $f$ \textbf{U} $g$ : For all paths the property globally $f$ holds \emph{until} property $g$ holds. 
\item $f$ \textbf{R} $g$ : f holds up to and including the point when $g$ holds.
\end{itemize}

%%%
%%% We need to formalise the following definition. Semantics of Linear Temporal Logic Formula?
%%% 
The semantics of LTL is defined inductively in terms of the $\mathbf{X}$ and $\mathbf{U}$ LTL operations which can then be used in combination with operator equivalences to define the semantics of other operations.
 
\begin{mydef}[Semantics of Linear Temporal Logic]
We define the semantics of a linear temporal logic formula $\phi \in LTL(AP)$ in terms of a satisfaction relation $$K,s \models \phi$$ over a Kripke structure $K = (S,T,L)$ and a state $s \in S$ as follows:

$$K,s \models \phi$$ holds if and only if $\forall \pi \in Path(K, s)$, $K,\pi \models \phi$ holds.

We define what it means for $K, \pi \models \phi$ to hold inductively as follows:

\begin{itemize} 
\item $K,\pi \models \phi$ always holds.

\item For all propositional formulae $p \in AP$ the following always holds:
     $$K,\pi \models p \leftrightarrow p \in L(\pi(0))$$

\item For all LTL formulas $\mathbf{X} \phi \in LTL(K)$ the following always holds:
$$ K, \pi \models \mathbf{X} \phi \leftrightarrow K, succ;\pi \models \phi $$

where $succ$ is a successor function $succ: N \_ \to N$ such that $succ;\pi(n) = \pi(succ(n)) = \pi(n + 1)$.

\item For all LTL formulas $\phi \mathbf{U} \psi \in LTL(K)$ the following always holds:
$$K, \pi \models_{LTL} \phi \mathbf{U} \psi \leftrightarrow$$
$$\exists n \in N.$$
$$(K,succ^n; \pi \models_{LTL} \psi) \wedge (\forall m \in N. m < n \to K, succ^m;\i \models_{LTL} \phi)$$

\item For all LTL formulas $\neg \phi \in LTL(AP)$ the following always holds:
$$K,\pi \models_{LTL} \neg \phi \leftrightarrow K,\pi \not\models \phi $$

\item For all LTL formulas $\phi \vee \psi \in LTL(AP)$ the following always holds
$$K,\pi \models_{LTL} \phi \vee \psi \leftrightarrow K,\pi \models_{LTL} \phi \ \mathrm{or} \ K,\pi \models_{LTL} \psi $$

\end{itemize}

\end{mydef}
In the above definition we have defined the semantics for the \textbf{U} and \textbf{X} LTL operations. 
The semantics for formulas containing other LTL operations can be obtained by using the following equivalences:
$$\textbf{G} \phi \equiv False \mathbf{R} \phi $$
$$\textbf{F} \phi \equiv  True \mathbf{U} \phi$$

Combined  with the equivalences for obtaining negative normal form.

\begin{mydef}[LTL Negative Normal Form]
The negative normal form of an LTL formula can be obtained by applying the following equivalences:
$$\neg True \equiv False$$
$$\neg False \equiv True$$
$$\neg \neg \phi \equiv \phi$$
$$\neg (\phi \vee \psi) \equiv \neg \phi \wedge \neg \psi $$
$$\neg (\phi \wedge \psi) \equiv \neg \phi \vee \neg \psi$$
$$\neg \mathbf{X} \phi \equiv \mathbf{X} \neg \phi$$
$$\neg (\phi \mathbf{U} \psi) \equiv (\neg \phi) \mathbf{R} (\neg \psi)$$
$$\neg (\phi \mathbf{R} \psi \equiv (\neg \phi) \mathbf{U} (\neg \psi)$$
from left to right until no further equivalence is applicable.
\end{mydef}

\section{Proof Systems}

\section{Natural Deduction}
The natural deduction proof system was introduced by Gentzen in 1939 \cite{GG69}. He was looking to capture the method by which humans naturally reason in a logical formalism.  The resulting system is very general and allows for new facts to be deduced from what is previously known in an intuitive manor. 

\begin{mydef}[Natural Deduction for Minimal Logic] 
The natural deduction proof system for minimal logic  consists of the following derivation terms for $\wedge$, $\to$ and $\forall$ : \\
\begin{center}
\centering
\begin{tabular}{| c | c |} \hline
derivation & term \\
\hline 
\raisebox{-1\height}{$u:A$} & \raisebox{-1\height}{$u^a$} \\ [3ex] \hline
\raisebox{-1.2\height}{
\AxiomC{$|M$}
\noLine
\UnaryInfC{$A$}
\AxiomC{$|N$}
\noLine
\UnaryInfC{$B $}
\RightLabel{$\wedge^+$}
\BinaryInfC{$A \wedge B$}
\DisplayProof} &  \raisebox{-2.8\height}{$\langle M^A, N^B \rangle^{A \wedge B}$} \\ [10ex]  \hline
\raisebox{-1.5\height}{
\AxiomC{$|M$}
\noLine
\UnaryInfC{$A \wedge B$}
\RightLabel{$\wedge^-_0$}
\UnaryInfC{$A$}
\DisplayProof \hspace{10pt}
\AxiomC{$|M$}
\noLine
\UnaryInfC{$A \wedge B$}
\RightLabel{$\wedge^-_1$}
\UnaryInfC{$A$}
\DisplayProof} & \raisebox{-2.8\height}{$(M^{A \wedge B} 0)^A \quad (M^{A \wedge B} 1)^B$} \\ [10ex] \hline

\raisebox{-1\height}{
\AxiomC{$\mathass{u: \,A}$}
\noLine
\UnaryInfC{$| \,M$}
\noLine
\UnaryInfC{$B$}
\RightLabel{$\to^+$}
\UnaryInfC{$A \to B$}
\DisplayProof} & \raisebox{-3.2\height}{$(\lambda u^AM^B)^{A \to B}$} \\ [12ex] \hline

\raisebox{-1\height}{\AxiomC{$A \to B$}
\AxiomC{$A$}
\RightLabel{$\to^-$}
\BinaryInfC{$B$}
\DisplayProof} & \raisebox{-1.2\height}{$(M^{A \to B} N^{A})^B$} \\ [5ex] \hline

\raisebox{-1\height}{
\AxiomC{$|M$}
\noLine
\UnaryInfC{$A$}
\RightLabel{$\forall^+x \ (var.cond.)$}
\UnaryInfC{$\forall x A$}
\DisplayProof} & \raisebox{-2.8\height}{$(\lambda x M^A)^{\forall x A} \, (var.cond.)$}  \\ [10ex] \hline

\raisebox{-1\height}{
\AxiomC{$|M$}
\noLine
\UnaryInfC{$\forall x. A$}
\AxiomC{t}
\RightLabel{$\forall^-$}
\BinaryInfC{$A[x:=t]$}
\DisplayProof} & \raisebox{-2.8\height}{$(M^{\forall x A}t)^{A[x:=t]}$} \\ [10ex] \hline

\end{tabular}
\end{center}

\end{mydef}


\begin{center}
\begin{tabular}{|c|c|} \hline
derivation & term \\ \hline

\raisebox{-1\height}{
\AxiomC{$t$}
\AxiomC{$|M$}
\noLine
\UnaryInfC{$A[x:=t]$}
\RightLabel{$\exists^+$}
\BinaryInfC{$\exists x A$}
\DisplayProof} & \raisebox{-2.2\height}{$(\exists^+_{x,A} t M^{A[x:=t]})^{\exists x A}$} \\ [10ex] \hline

\raisebox{-1\height}{
\AxiomC{$\exists x. A$}
\AxiomC{$\mathass{(a/x)A}$}
\noLine
\UnaryInfC{$\vdots$}
\noLine
\UnaryInfC{$C$}
\RightLabel{$\exists^- (var.cond.)$}
\BinaryInfC{$C$}
\DisplayProof} & \raisebox{-3.8\height}{($M^{\exists x A}(u^A.N^B))^B$ (var.cond.)} \\ [15ex] \hline



\AxiomC{$A$}
\LeftLabel{$\vee \mhyphen intro \, (L)$}
\UnaryInfC{$A \vee B$}
\DisplayProof \hspace{10pt}
\AxiomC{$B$}
\LeftLabel{$\vee \mhyphen intro \, (R)$}
\UnaryInfC{$A \vee B$}
\DisplayProof \\
 
\bigskip

\AxiomC{$A \wedge B$}
\AxiomC{$\mathass{A}$}
\noLine
\UnaryInfC{\vdots}
\noLine
\UnaryInfC{$C$}
\AxiomC{$\mathass{B}$}
\noLine
\UnaryInfC{\vdots}
\noLine
\UnaryInfC{$C$}
\LeftLabel{$\vee \mhyphen elim$}
\TrinaryInfC{$C$}
\DisplayProof
\end{tabular}
\end{center}


\medskip
\begin{center}
\AxiomC{$\bot$}
\LeftLabel{efq}
\UnaryInfC{$A$}
\DisplayProof 
\end{center}
\medskip



\subsection*{Type}
Inorder to perform program extraction on a proof we must first deduce the
type of the program to be extracted from a formula. In \cite{mlcf} the
type of a formula $A$ is represented by the object $\tau (A)$. If the formula
$A$ contains some computational content then the $\tau (A)$ represents the type
of the program extracted from $A$. If $A$ however does not contain any
computational content then $\tau (A) = \epsilon$.
We will now give a formal defintion of $\tau (A)$ starting with the type of a
predicate variable. If the predicate variable has some assignment $\alpha_P$ then the type of that
formula is the value of the assignment.


\[
\tau(P(\vec{s})) := \left\{ 
\begin{array}{l l}
  \alpha_P & \quad \text{if $P$ is a predicate variable with assigned $\alpha_P$}\\
 \epsilon & \quad \text{otherwise}\\
\end{array} \right.
\]

The type of a formula containing an existential quantifier and a subformula
$A$ is dependent on the type of $A$. If $A$ contains no computational content
i.e. $\tau(A) = \epsilon$ then the type of the formula is that of the bound
variable $x$. Otherwise the type is a product of the type of the bound
variable $\rho$ and the type of the formula $A$ $\tau (A)$.

\[
\tau(\exists x^{\rho} A) := \left\{ 
\begin{array}{l l}
  \rho & \quad \text{if $\tau(A) = \epsilon$}\\
 \rho \times \tau (A) & \quad \text{otherwise}\\
\end{array} \right.
\]


The type of a formula containing a universal quantifier and a subformula $A$
is also dependent on the type of $A$. If $A$ contains no computational content
i.e. $\tau (A) = \epsilon$ then the type of the whole formula is also
$\epsilon$. Otherwise if $A$ does have some computational content then the type
of the formula is a function with $\rho$ as a parameter and returns a result
of type $\tau (A)$.


\[
\tau(\forall x^{\rho} A) := \left\{ 
\begin{array}{l l}
  \epsilon & \quad \text{if $\tau(A) = \epsilon$}\\
 \rho \to \tau (A) & \quad \text{otherwise}\\
\end{array} \right.
\]


The type of a formula $A \to B$ containing the implication operator and
subformulae $A$ and $B$ is dependent on the types of the subformulae.
If $\tau (A) = \epsilon$ then the type of the formula is $ \tau (B)$. If $\tau
(B) = \epsilon$ then the type of the formula is $\epsilon$. Otherwise it
returns a function that has a parameter with a type of $\tau (A)$ and returns a value with
a type of $\tau (B)$.

\[
\tau(\forall x^{\rho} A) := \left\{ 
\begin{array}{l l}
  \tau (B) & \quad \text{if $\tau (A) = \epsilon$}\\
  \epsilon & \quad \text{if $\tau (B) = \epsilon$}\\
  \tau (A) \to \tau (B) & \quad \text{otherwise}\\
\end{array} \right.
\]

\subsection*{The Extracted Program}
I will now give a definition of a extracted program $\llbracket M \rrbracket$
which has a type $\tau (A)$. Where $M$ is a derivation of the formula $A$ with
$A$ having a defined type i.e. $ \tau (A) \neq \epsilon $.

\[ \llbracket u^A \rrbracket := x^{\tau (A)}_{u} \text{$x^{\tau (A)}_u$
  uniquely associated with $u^A$}
\]

\[
\llbracket \lambda u^A M \rrbracket := \left\{ 
\begin{array}{l l}
\llbracket M \rrbracket  & \quad \text{if $\tau (A) = \epsilon$} \\ 
\lambda x^{\tau (A)}_{u} \llbracket M \rrbracket & \quad \text{otherwise} \\

\end{array} \right.
 \]

\[
\llbracket M^{A \to B} N \rrbracket := \left\{ 
\begin{array}{l l}
\llbracket M \rrbracket  & \quad \text{if $\tau (A) = \epsilon$} \\ 
\llbracket M \rrbracket  \llbracket N \rrbracket & \quad \text{otherwise} \\

\end{array} \right.
 \]

\[
\llbracket \langle M^{A_0}_0, M^{A_1}_1 \rangle \rrbracket := \left\{ 
\begin{array}{l l}
\llbracket M_i \rrbracket  & \quad \text{if $\tau (A_{1-i}) = \epsilon$} \\ 
\langle \llbracket M_0 \rrbracket , \llbracket M_1 \rrbracket \rangle & \quad \text{otherwise} \\

\end{array} \right.
 \]




$$\llbracket ( \lambda x^{\rho} M)^{\forall x A} \rrbracket := \lambda x^{\rho} \llbracket   M \rrbracket$$





$$\llbracket M^{\forall x A} t \rrbracket := \llbracket M \rrbracket t$$



The axioms for dealing with existential quantifiers produce slightly more
complicated programs upon extraction. 

$$ \exists^+_{x,A} : \forall x^{\rho}.A \to \exists x^{\rho} A    ex-intro$$
$$ \exists^-_{x,A,B} : \exists x^{\rho} A \to (\forall x^{\rho}. A \to B) \to
B  ex-elim$$

The following are the extracted programs for the above axioms.

\[ \llbracket \exists^{+}_{x^{\rho}, A} \rrbracket := \left\{ 
\begin{array}{l l}
\lambda x^{\rho} x  & \quad \text{if $\tau (A) = \epsilon$} \\ 
\lambda x^{\rho} \lambda y^{\tau (A)} \langle x,y \rangle & \quad \text{otherwise} \\

\end{array} \right.
\]



\[ \llbracket \exists^{-}_{x^{\rho}, A, B} \rrbracket := \left\{ 
\begin{array}{l l}
\lambda x^{\rho} \lambda f^{\rho \to \tau (B)}. f x  & \quad \text{if $\tau (A) = \epsilon$} \\ 
\lambda z^{\rho \times \tau (A)} \lambda f^{\rho \to \tau (A) \to \tau (B)}. f
(z0) (z1) & \quad \text{otherwise} \\

\end{array} \right.
\]



\subsection*{Realizability}
We need to have a notion of what it means for an extracted program to realize
a formula. The notion that we define to do this is called realizability. Which takes shape as a formula $r \textbf{r} A$ this can be read as
a term $r$ realizes a formula $A$. If $\tau(A) \neq \epsilon$ then $r$ is of type $\tau (A)$,
otherwise $r$ is the symbol $\epsilon$. We also need to define relizability
for predicates. If we have a predicate P
with an arity $\vec{\rho}$ then there are two possibilities here. One is that
$P$ is a Predicate variable with an assigned $\alpha_P$ for this we create a new
predicate variable $P^{\textbf{r}}$ with an arity of $\alpha_P,\vec{\rho}$. 
The other case is that $P$ is a predicate constant , if this is the case then
we use the predicate constant.



\[ r \ \textbf{r} \ P(\vec{s}) = \left\{ 
\begin{array}{l l}
P^r(r,\vec{s}) & \quad \text{if $P$ is a predicate variable with assigned $\alpha_P$} \\ 
P(\vec{s}) & \quad \text{if P is a predicate constant} \\

\end{array} \right.
\]

\[ r \ \textbf{r} \ (\exists x A) = \left\{ 
\begin{array}{l l}
\epsilon \ \textbf{r} \ A[x:=r] & \quad \text{if $\tau (A) = \epsilon$} \\ 
r1 \ \textbf{r} \ A[x:= r0] & \quad \text{otherwise} \\

\end{array} \right.
\]

\[ r \ \textbf{r} \ (\forall x A) = \left\{ 
\begin{array}{l l}
\forall x. \epsilon \ \textbf{r} \ A & \quad \text{if $\tau (A) = \epsilon$} \\ 
\forall x. rx \ \textbf{r} \ A & \quad \text{otherwise} \\

\end{array} \right.
\]

\[ r \ \textbf{r} \ (A \to B) = \left\{ 
\begin{array}{l l}
\epsilon \ \textbf{r} \ A \to r \ \textbf{r} \ B & \quad \text{if $\tau (A) = \epsilon$} \\ 
\forall x.x \ \textbf{r} \ A \to \epsilon \ \textbf{r} \ B & \quad \text{if
  $\tau (A) \neq \epsilon \neq \tau (B)$} \\
\forall x. x \ \textbf{r} \ A \to r x  \ \textbf{r} \ B & \quad \text{otherwise} \\

\end{array} \right.
\]


\begin{comment}

\subsection*{Soundness Theorem}


\begin{theorem}
\emph{(Soundness Theorem)}

If $M$ is a proof of a formula $B$, then we can derive  $ \llbracket M \rrbracket \ \textbf{r} \ B$.
\end{theorem}

We begin the proof by performing induction on the proof term M.

\begin{description}

\item[Case] $\lambda u^A M^B$ We must derive $$\llbracket \lambda u^A M^B
  \rrbracket \textbf{r} B$$
   \begin{description}
     \item[Subcase] $\tau(A) = \epsilon$ In this case the empty term realises
       A, making the $\lambda u $ redundant, which implies that the extracted
       program from M realises B $$\llbracket \lambda u M \rrbracket
       \textbf{r} (A \to B) = \epsilon \textbf{r} A \to \llbracket M
       \rrbracket \textbf{r} B$$
     \item[Subcase] $\tau(A) \neq \epsilon \eq \tau (B)$ In this case the
       extracted program is empty $ \llbracket \lambda u M \rrbracket = \epsilon$.

       $$\llbracket \lambda u M \rrbracket \textbf{r} (A \to B) = \forall
       x. x \textbf{r} A \to \epsilon \textbf{r} B$$
     \item[Subcase]$\tau (A) \neq \epsilon \neq \tau (B)$ neither the type of $A$ or $B$ is empty. Therefore if we have an $x$ that
       realises $A$ then this $x$ applied to the extracted program realises B.
         

   \end{description}

\item[Case] $\exists^+_{x,A}$ We now consider the case that an existential
  introduction axiom had been applied in the proof. The axiom takes the
  following form $$\exists^+_{x,A}: \forall^{nc} \vec{\rho} \forall x. A \to
  \exists x A $$
  For our proof of the soundness theorem we need to find a derivation
  of $$\llbracket \exists^+_{x,A} \rrbracket \textbf{r} \forall^{nc}
  \vec{\rho} \forall x.A \to \exists x A$$

  \begin{description}
   
   \item[Subcase] $\tau (A) \eq epsilon$ If the type of A is empty then the
     extracted program is $\lambda x x$ which realises the formula
     corresponding to the existential introduction axiom.

     $$(\lamba x x) \textbf{r}  \forall^{nc} \vec{\rho} \forall x. A \to
  \exists x A  \eq  \forall^{nc} \vec{\rho} \forall x.x \textbf{r} (A \to
  \exists x A) $$

  Since $\tau (A) \eq \epsilon$ the empty program realises A.
  $$\forall^{nc} \vec{\rho} \forall x.x \textbf{r} (A \to
  \exists x A )  \eq \forall^{nc} \vec{\rho} \forall x.\epsilon \textbf{r} A \to
  x \textbf{r} \exists x A $$

  $$\forall^{nc} \vec{\rho} \forall x.\epsilon \textbf{r} A \to
  x \textbf{r} \exists x A \eq \forall^{nc} \vec{\rho} \forall x.\epsilon \textbf{r} A \to
  \epsilon \textbf{r}  A $$

   \item[Subcase] $\tau (A) \neq \epsilon$ If the type of A is non empty then
     the extracted program is $\lambda x \lambda f \langle x ,f \rangle$ which
     realises the formula corresponding to the existential introduction axiom.

     $$ \lambda x \lambda f \langle x ,f \rangle \textbf{r}  \forall^{nc} \vec{\rho} \forall x. A \to
  \exists x A  \eq  \forall^{nc} \vec{\rho} \forall x,f. f \textbf{r} A \to
   \langle x ,f \rangle \textbf{r} \exists x A $$

       $$ \forall^{nc} \vec{\rho} \forall x,f. f \textbf{r} A \to
   \langle x ,f \rangle \textbf{r} \exists x A  \eq \forall^{nc} \vec{\rho} \forall x,f. f \textbf{r} A \to
   f \textbf{r} A  $$
  \end{description}

  \item[Case] $\exists^-_{x,A,B}$  We now consider the case that an
    existential elimination axiom had been applied in the proof. The axiom
    takes the following form $$\exists^-_{x,A,B}: \forall^{nc}
    \vec{\rho}.\exists x A \to (\forall x. A \to B) \to B $$ for the proof of
    our theorem we need to find a derivation of $$\llbracket
    \exists^-_{x,A,B} \rrbracket \textbf{r} \forall^{nc} \vec{\rho}. \exists
    x A \to (\forall x. A \to B) \to B$$
    \item[Subcase] $\tau (A) \eq \epsilon \eq \tau (B)$ The extracted program
      in this case is the empty program that is $ \llbracket \exists^-_{x,A,B}
      \rrbracket = \epsilon $

      $$\epsilon \textbf{r} \forall^{nc} \vec{\rho}. \exists
       x A \to (\forall x. A \to B) \to B 
      \eq \forall^{nc} \vec{\rho} \forall x. x \textbf{r} \exists x A \to \epsilon \textbf{r}((\forall x. A \to B) \to B) 
      \eq \forall^{nc} \vec{\rho} \forall x. \epsilon \textbf{r} A \to
      \epsilon \textbf{r}(\forall x. A \to B) \to \epsilon \textbf{r} B  
      \eq \forall^{nc} \vec{\rho} \forall x. \epsilon \textbf{r} A \to
      \forall x \epsilon \textbf{r}(A \to B) \to \epsilon \textbf{r} B
      \eq \forall^{nc} \vec{\rho} \forall x. \epsilon \textbf{r} A \to
      (\forall x. \epsilon \textbf{r} A \to \epsilon \textbf{r} B) \to
      \epsilon \textbf{r} B$$

    \item[Subcase] $\tau (A) \neq \epsilon \eq \tau(B)$ Once again the
      extracted program in this case is the empty program that is $ \llbracket \exists^-_{x,A,B}
      \rrbracket = \epsilon $




    \item[Subcase] $\tau (A) \eq \epsilon \neq \tau(B)$
    \item[Subcase] $\tau (A) \neq \epsilon \neq \tau(B)$






\end{description}
\end{comment}
